// ===================== begin_copyright_notice ============================
//
// Copyright (C) 2023 Intel Corporation
//
// SPDX-License-Identifier: MIT
//
// ===================== end_copyright_notice ==============================

/**
* @file   openglArguments.cpp
*
* @brief  Definitions of OpenGL library function call argument wrappers.
*
*/

#include "mapping.h"
#include "streams.h"
#include "openglLibrary.h"
#include "stateDynamic.h"
#include "gits.h"
#include "exception.h"
#include "log.h"
#include "openglDrivers.h"
#include "buffer.h"
#include "config.h"
#include "platform.h"
#include "glxArguments.h"
#include <limits>
#include <cstring>
#include <algorithm>
#include <iomanip>
#include <iostream>
#include <map>
#include <set>
#include <sstream>
#include <iomanip>

/* *********************************** E N U M ********************************* */

const char* gits::OpenGL::CGLenum::NAME = "GLenum";

gits::OpenGL::CGLenum::CGLenum() {}

gits::OpenGL::CGLenum::CGLenum(GLenum value) : CGLtype<GLtype, type, GLushort>(value) {}

void gits::OpenGL::CGLenum::Write(CCodeOStream& stream) const {
  // stream << std::setfill('0') << std::setw(LENGTH * 2) << std::hex <<
  // Value();
  stream << EnumString(Value());
}

// this does not contain *_ATI nor *_NV enums
#define ENUM_MAPPING(enum_name)                                                                    \
  { enum_name, #enum_name }
gits::OpenGL::CGLenum::TEnumName gits::OpenGL::CGLenum::_enumNames[] = {
    ENUM_MAPPING(GL_1PASS_EXT),
    ENUM_MAPPING(GL_2_BYTES),
    ENUM_MAPPING(GL_2D),
    ENUM_MAPPING(GL_2PASS_0_EXT),
    ENUM_MAPPING(GL_2PASS_1_EXT),
    ENUM_MAPPING(GL_3_BYTES),
    ENUM_MAPPING(GL_3D),
    ENUM_MAPPING(GL_3D_COLOR),
    ENUM_MAPPING(GL_3D_COLOR_TEXTURE),
    ENUM_MAPPING(GL_4_BYTES),
    ENUM_MAPPING(GL_422_AVERAGE_EXT),
    ENUM_MAPPING(GL_422_EXT),
    ENUM_MAPPING(GL_422_REV_AVERAGE_EXT),
    ENUM_MAPPING(GL_422_REV_EXT),
    ENUM_MAPPING(GL_4D_COLOR_TEXTURE),
    ENUM_MAPPING(GL_4PASS_0_EXT),
    ENUM_MAPPING(GL_4PASS_1_EXT),
    ENUM_MAPPING(GL_4PASS_2_EXT),
    ENUM_MAPPING(GL_4PASS_3_EXT),
    ENUM_MAPPING(GL_ABGR_EXT),
    ENUM_MAPPING(GL_ACCUM),
    ENUM_MAPPING(GL_ACCUM_ALPHA_BITS),
    ENUM_MAPPING(GL_ACCUM_BLUE_BITS),
    ENUM_MAPPING(GL_ACCUM_BUFFER_BIT),
    ENUM_MAPPING(GL_ACCUM_CLEAR_VALUE),
    ENUM_MAPPING(GL_ACCUM_GREEN_BITS),
    ENUM_MAPPING(GL_ACCUM_RED_BITS),
    ENUM_MAPPING(GL_ACTIVE_ATTRIBUTE_MAX_LENGTH),
    ENUM_MAPPING(GL_ACTIVE_ATTRIBUTES),
    ENUM_MAPPING(GL_ACTIVE_STENCIL_FACE_EXT),
    ENUM_MAPPING(GL_ACTIVE_TEXTURE),
    ENUM_MAPPING(GL_ACTIVE_UNIFORM_MAX_LENGTH),
    ENUM_MAPPING(GL_ACTIVE_UNIFORMS),
    ENUM_MAPPING(GL_ACTIVE_VERTEX_UNITS_ARB),
    ENUM_MAPPING(GL_ADD),
    ENUM_MAPPING(GL_ADD_SIGNED_ARB),
    ENUM_MAPPING(GL_ALIASED_LINE_WIDTH_RANGE),
    ENUM_MAPPING(GL_ALIASED_POINT_SIZE_RANGE),
    ENUM_MAPPING(GL_ALL_ATTRIB_BITS),
    ENUM_MAPPING(GL_ALLOW_DRAW_FRG_HINT_PGI),
    ENUM_MAPPING(GL_ALLOW_DRAW_MEM_HINT_PGI),
    ENUM_MAPPING(GL_ALLOW_DRAW_OBJ_HINT_PGI),
    ENUM_MAPPING(GL_ALLOW_DRAW_WIN_HINT_PGI),
    ENUM_MAPPING(GL_ALPHA),
    ENUM_MAPPING(GL_ALPHA_BIAS),
    ENUM_MAPPING(GL_ALPHA_BITS),
    ENUM_MAPPING(GL_ALPHA_INTEGER_EXT),
    ENUM_MAPPING(GL_ALPHA_MAX_CLAMP_INGR),
    ENUM_MAPPING(GL_ALPHA_MAX_SGIX),
    ENUM_MAPPING(GL_ALPHA_MIN_CLAMP_INGR),
    ENUM_MAPPING(GL_ALPHA_MIN_SGIX),
    ENUM_MAPPING(GL_ALPHA_SCALE),
    ENUM_MAPPING(GL_ALPHA_TEST),
    ENUM_MAPPING(GL_ALPHA_TEST_FUNC),
    ENUM_MAPPING(GL_ALPHA_TEST_REF),
    ENUM_MAPPING(GL_ALPHA12),
    ENUM_MAPPING(GL_ALPHA16),
    ENUM_MAPPING(GL_ALPHA16F_ARB),
    ENUM_MAPPING(GL_ALPHA16I_EXT),
    ENUM_MAPPING(GL_ALPHA16UI_EXT),
    ENUM_MAPPING(GL_ALPHA32F_ARB),
    ENUM_MAPPING(GL_ALPHA32I_EXT),
    ENUM_MAPPING(GL_ALPHA32UI_EXT),
    ENUM_MAPPING(GL_ALPHA4),
    ENUM_MAPPING(GL_ALPHA8),
    ENUM_MAPPING(GL_ALPHA8I_EXT),
    ENUM_MAPPING(GL_ALPHA8UI_EXT),
    ENUM_MAPPING(GL_ALWAYS),
    ENUM_MAPPING(GL_ALWAYS_FAST_HINT_PGI),
    ENUM_MAPPING(GL_ALWAYS_SOFT_HINT_PGI),
    ENUM_MAPPING(GL_AMBIENT),
    ENUM_MAPPING(GL_AMBIENT_AND_DIFFUSE),
    ENUM_MAPPING(GL_AND),
    ENUM_MAPPING(GL_AND_INVERTED),
    ENUM_MAPPING(GL_AND_REVERSE),
    ENUM_MAPPING(GL_ARRAY_BUFFER),
    ENUM_MAPPING(GL_ELEMENT_ARRAY_BUFFER),
    ENUM_MAPPING(GL_PIXEL_PACK_BUFFER),
    ENUM_MAPPING(GL_PIXEL_UNPACK_BUFFER),
    ENUM_MAPPING(GL_ARRAY_BUFFER_BINDING),
    ENUM_MAPPING(GL_ARRAY_ELEMENT_LOCK_COUNT_EXT),
    ENUM_MAPPING(GL_ARRAY_ELEMENT_LOCK_FIRST_EXT),
    ENUM_MAPPING(GL_ASYNC_DRAW_PIXELS_SGIX),
    ENUM_MAPPING(GL_ASYNC_HISTOGRAM_SGIX),
    ENUM_MAPPING(GL_ASYNC_MARKER_SGIX),
    ENUM_MAPPING(GL_ASYNC_READ_PIXELS_SGIX),
    ENUM_MAPPING(GL_ASYNC_TEX_IMAGE_SGIX),
    ENUM_MAPPING(GL_ATTACHED_SHADERS),
    ENUM_MAPPING(GL_ATTENUATION_EXT),
    ENUM_MAPPING(GL_ATTRIB_STACK_DEPTH),
    ENUM_MAPPING(GL_AUTO_NORMAL),
    ENUM_MAPPING(GL_AUX_BUFFERS),
    ENUM_MAPPING(GL_AUX0),
    ENUM_MAPPING(GL_AUX1),
    ENUM_MAPPING(GL_AUX2),
    ENUM_MAPPING(GL_AUX3),
    ENUM_MAPPING(GL_AVERAGE_EXT),
    ENUM_MAPPING(GL_AVERAGE_HP),
    ENUM_MAPPING(GL_BACK),
    ENUM_MAPPING(GL_BACK_LEFT),
    ENUM_MAPPING(GL_BACK_NORMALS_HINT_PGI),
    ENUM_MAPPING(GL_BACK_RIGHT),
    ENUM_MAPPING(GL_BGR_EXT),
    ENUM_MAPPING(GL_BGR_INTEGER_EXT),
    ENUM_MAPPING(GL_BGRA_EXT),
    ENUM_MAPPING(GL_BGRA_INTEGER_EXT),
    ENUM_MAPPING(GL_BINORMAL_ARRAY_EXT),
    ENUM_MAPPING(GL_BINORMAL_ARRAY_POINTER_EXT),
    ENUM_MAPPING(GL_BINORMAL_ARRAY_STRIDE_EXT),
    ENUM_MAPPING(GL_BINORMAL_ARRAY_TYPE_EXT),
    ENUM_MAPPING(GL_BITMAP),
    ENUM_MAPPING(GL_BITMAP_TOKEN),
    ENUM_MAPPING(GL_BLEND),
    ENUM_MAPPING(GL_BLEND_COLOR),
    ENUM_MAPPING(GL_BLEND_DST),
    ENUM_MAPPING(GL_BLEND_DST_ALPHA),
    ENUM_MAPPING(GL_BLEND_DST_RGB),
    ENUM_MAPPING(GL_BLEND_EQUATION_ALPHA),
    ENUM_MAPPING(GL_BLEND_EQUATION_RGB),
    ENUM_MAPPING(GL_BLEND_SRC),
    ENUM_MAPPING(GL_BLEND_SRC_ALPHA),
    ENUM_MAPPING(GL_BLEND_SRC_RGB),
    ENUM_MAPPING(GL_BLUE),
    ENUM_MAPPING(GL_BLUE_BIAS),
    ENUM_MAPPING(GL_BLUE_BITS),
    ENUM_MAPPING(GL_BLUE_INTEGER_EXT),
    ENUM_MAPPING(GL_BLUE_MAX_CLAMP_INGR),
    ENUM_MAPPING(GL_BLUE_MIN_CLAMP_INGR),
    ENUM_MAPPING(GL_BLUE_SCALE),
    ENUM_MAPPING(GL_BOOL_VEC2),
    ENUM_MAPPING(GL_BOOL_VEC3),
    ENUM_MAPPING(GL_BOOL_VEC4),
    ENUM_MAPPING(GL_BUFFER_ACCESS),
    ENUM_MAPPING(GL_BUFFER_FLUSHING_UNMAP_APPLE),
    ENUM_MAPPING(GL_BUFFER_MAP_POINTER),
    ENUM_MAPPING(GL_BUFFER_MAPPED),
    ENUM_MAPPING(GL_BUFFER_SERIALIZED_MODIFY_APPLE),
    ENUM_MAPPING(GL_BUFFER_SIZE),
    ENUM_MAPPING(GL_BUFFER_USAGE),
    ENUM_MAPPING(GL_BYTE),
    ENUM_MAPPING(GL_C3F_V3F),
    ENUM_MAPPING(GL_C4F_N3F_V3F),
    ENUM_MAPPING(GL_C4UB_V2F),
    ENUM_MAPPING(GL_C4UB_V3F),
    ENUM_MAPPING(GL_CALLIGRAPHIC_FRAGMENT_SGIX),
    ENUM_MAPPING(GL_CCW),
    ENUM_MAPPING(GL_CLAMP),
    ENUM_MAPPING(GL_CLAMP_FRAGMENT_COLOR_ARB),
    ENUM_MAPPING(GL_CLAMP_READ_COLOR_ARB),
    ENUM_MAPPING(GL_CLAMP_TO_BORDER),
    ENUM_MAPPING(GL_CLAMP_TO_EDGE),
    ENUM_MAPPING(GL_CLAMP_VERTEX_COLOR_ARB),
    ENUM_MAPPING(GL_CLEAR),
    ENUM_MAPPING(GL_CLIENT_ACTIVE_TEXTURE),
    ENUM_MAPPING(GL_CLIENT_ALL_ATTRIB_BITS),
    ENUM_MAPPING(GL_CLIENT_ATTRIB_STACK_DEPTH),
    ENUM_MAPPING(GL_CLIENT_PIXEL_STORE_BIT),
    ENUM_MAPPING(GL_CLIENT_VERTEX_ARRAY_BIT),
    ENUM_MAPPING(GL_CLIP_FAR_HINT_PGI),
    ENUM_MAPPING(GL_CLIP_NEAR_HINT_PGI),
    ENUM_MAPPING(GL_CLIP_PLANE0),
    ENUM_MAPPING(GL_CLIP_PLANE1),
    ENUM_MAPPING(GL_CLIP_PLANE2),
    ENUM_MAPPING(GL_CLIP_PLANE3),
    ENUM_MAPPING(GL_CLIP_PLANE4),
    ENUM_MAPPING(GL_CLIP_PLANE5),
    ENUM_MAPPING(GL_CLIP_VOLUME_CLIPPING_HINT_EXT),
    ENUM_MAPPING(GL_CMYK_EXT),
    ENUM_MAPPING(GL_CMYKA_EXT),
    ENUM_MAPPING(GL_COEFF),
    ENUM_MAPPING(GL_COLOR),
    ENUM_MAPPING(GL_COLOR_ARRAY),
    ENUM_MAPPING(GL_COLOR_ARRAY_BUFFER_BINDING),
    ENUM_MAPPING(GL_COLOR_ARRAY_COUNT_EXT),
    //  ENUM_MAPPING( GL_COLOR_ARRAY_EXT ),
    ENUM_MAPPING(GL_COLOR_ARRAY_LIST_IBM),
    ENUM_MAPPING(GL_COLOR_ARRAY_LIST_STRIDE_IBM),
    ENUM_MAPPING(GL_COLOR_ARRAY_PARALLEL_POINTERS_INTEL),
    ENUM_MAPPING(GL_COLOR_ARRAY_POINTER),
    ENUM_MAPPING(GL_COLOR_ARRAY_POINTER_EXT),
    ENUM_MAPPING(GL_COLOR_ARRAY_SIZE),
    ENUM_MAPPING(GL_COLOR_ARRAY_SIZE_EXT),
    ENUM_MAPPING(GL_COLOR_ARRAY_STRIDE),
    ENUM_MAPPING(GL_COLOR_ARRAY_STRIDE_EXT),
    ENUM_MAPPING(GL_COLOR_ARRAY_TYPE),
    ENUM_MAPPING(GL_COLOR_ARRAY_TYPE_EXT),
    ENUM_MAPPING(GL_COLOR_ATTACHMENT0_EXT),
    ENUM_MAPPING(GL_COLOR_ATTACHMENT1_EXT),
    ENUM_MAPPING(GL_COLOR_ATTACHMENT10_EXT),
    ENUM_MAPPING(GL_COLOR_ATTACHMENT11_EXT),
    ENUM_MAPPING(GL_COLOR_ATTACHMENT12_EXT),
    ENUM_MAPPING(GL_COLOR_ATTACHMENT13_EXT),
    ENUM_MAPPING(GL_COLOR_ATTACHMENT14_EXT),
    ENUM_MAPPING(GL_COLOR_ATTACHMENT15_EXT),
    ENUM_MAPPING(GL_COLOR_ATTACHMENT2_EXT),
    ENUM_MAPPING(GL_COLOR_ATTACHMENT3_EXT),
    ENUM_MAPPING(GL_COLOR_ATTACHMENT4_EXT),
    ENUM_MAPPING(GL_COLOR_ATTACHMENT5_EXT),
    ENUM_MAPPING(GL_COLOR_ATTACHMENT6_EXT),
    ENUM_MAPPING(GL_COLOR_ATTACHMENT7_EXT),
    ENUM_MAPPING(GL_COLOR_ATTACHMENT8_EXT),
    ENUM_MAPPING(GL_COLOR_ATTACHMENT9_EXT),
    ENUM_MAPPING(GL_COLOR_BUFFER_BIT),
    ENUM_MAPPING(GL_COLOR_CLEAR_VALUE),
    ENUM_MAPPING(GL_COLOR_INDEX),
    ENUM_MAPPING(GL_COLOR_INDEX1_EXT),
    ENUM_MAPPING(GL_COLOR_INDEX12_EXT),
    ENUM_MAPPING(GL_COLOR_INDEX16_EXT),
    ENUM_MAPPING(GL_COLOR_INDEX2_EXT),
    ENUM_MAPPING(GL_COLOR_INDEX4_EXT),
    ENUM_MAPPING(GL_COLOR_INDEX8_EXT),
    ENUM_MAPPING(GL_COLOR_INDEXES),
    ENUM_MAPPING(GL_COLOR_LOGIC_OP),
    ENUM_MAPPING(GL_COLOR_MATERIAL),
    ENUM_MAPPING(GL_COLOR_MATERIAL_FACE),
    ENUM_MAPPING(GL_COLOR_MATERIAL_PARAMETER),
    ENUM_MAPPING(GL_COLOR_MATRIX_STACK_DEPTH),
    ENUM_MAPPING(GL_COLOR_TABLE_ALPHA_SIZE_SGI),
    ENUM_MAPPING(GL_COLOR_TABLE_BIAS),
    ENUM_MAPPING(GL_COLOR_TABLE_SCALE),
    ENUM_MAPPING(GL_COLOR_TABLE_SGI),
    ENUM_MAPPING(GL_COLOR_WRITEMASK),
    ENUM_MAPPING(GL_COLOR3_BIT_PGI),
    ENUM_MAPPING(GL_COLOR4_BIT_PGI),
    ENUM_MAPPING(GL_COMBINE_ALPHA),
    ENUM_MAPPING(GL_COMBINE_RGB),
    ENUM_MAPPING(GL_COMPARE_R_TO_TEXTURE),
    ENUM_MAPPING(GL_COMPARE_REF_DEPTH_TO_TEXTURE_EXT),
    ENUM_MAPPING(GL_COMPILE),
    ENUM_MAPPING(GL_COMPILE_AND_EXECUTE),
    ENUM_MAPPING(GL_COMPILE_STATUS),
    ENUM_MAPPING(GL_COMPRESSED_ALPHA),
    ENUM_MAPPING(GL_COMPRESSED_INTENSITY),
    ENUM_MAPPING(GL_COMPRESSED_LUMINANCE_ALPHA_LATC2_EXT),
    ENUM_MAPPING(GL_COMPRESSED_LUMINANCE_LATC1_EXT),
    ENUM_MAPPING(GL_COMPRESSED_RED_GREEN_RGTC2_EXT),
    ENUM_MAPPING(GL_COMPRESSED_RED_RGTC1_EXT),
    ENUM_MAPPING(GL_COMPRESSED_RGB_FXT1_3DFX),
    ENUM_MAPPING(GL_COMPRESSED_RGB_S3TC_DXT1_EXT),
    ENUM_MAPPING(GL_COMPRESSED_RGBA_FXT1_3DFX),
    ENUM_MAPPING(GL_COMPRESSED_RGBA_S3TC_DXT1_EXT),
    ENUM_MAPPING(GL_COMPRESSED_RGBA_S3TC_DXT3_EXT),
    ENUM_MAPPING(GL_COMPRESSED_RGBA_S3TC_DXT5_EXT),
    ENUM_MAPPING(GL_COMPRESSED_SIGNED_LUMINANCE_ALPHA_LATC2_EXT),
    ENUM_MAPPING(GL_COMPRESSED_SIGNED_LUMINANCE_LATC1_EXT),
    ENUM_MAPPING(GL_COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT),
    ENUM_MAPPING(GL_COMPRESSED_SIGNED_RED_RGTC1_EXT),
    ENUM_MAPPING(GL_COMPRESSED_SLUMINANCE_ALPHA),
    ENUM_MAPPING(GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT),
    ENUM_MAPPING(GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT),
    ENUM_MAPPING(GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT),
    ENUM_MAPPING(GL_COMPRESSED_SRGB_S3TC_DXT1_EXT),
    ENUM_MAPPING(GL_COMPRESSED_TEXTURE_FORMATS),
    ENUM_MAPPING(GL_CONSERVE_MEMORY_HINT_PGI),
    ENUM_MAPPING(GL_CONSTANT_ALPHA),
    ENUM_MAPPING(GL_CONSTANT_ATTENUATION),
    ENUM_MAPPING(GL_CONSTANT_BORDER),
    ENUM_MAPPING(GL_CONVOLUTION_1D),
    ENUM_MAPPING(GL_CONVOLUTION_2D),
    ENUM_MAPPING(GL_CONVOLUTION_BORDER_COLOR),
    ENUM_MAPPING(GL_CONVOLUTION_BORDER_MODE),
    ENUM_MAPPING(GL_CONVOLUTION_FILTER_BIAS),
    ENUM_MAPPING(GL_CONVOLUTION_FILTER_SCALE),
    ENUM_MAPPING(GL_CONVOLUTION_FORMAT),
    ENUM_MAPPING(GL_CONVOLUTION_HEIGHT),
    ENUM_MAPPING(GL_CONVOLUTION_HINT_SGIX),
    ENUM_MAPPING(GL_CONVOLUTION_WIDTH),
    ENUM_MAPPING(GL_COORD_REPLACE),
    ENUM_MAPPING(GL_COPY),
    ENUM_MAPPING(GL_COPY_INVERTED),
    ENUM_MAPPING(GL_COPY_PIXEL_TOKEN),
    ENUM_MAPPING(GL_CUBIC_EXT),
    ENUM_MAPPING(GL_CULL_FACE),
    ENUM_MAPPING(GL_CULL_FACE_MODE),
    ENUM_MAPPING(GL_CULL_VERTEX_EXT),
    ENUM_MAPPING(GL_CULL_VERTEX_EYE_POSITION_EXT),
    ENUM_MAPPING(GL_CULL_VERTEX_IBM),
    ENUM_MAPPING(GL_CULL_VERTEX_OBJECT_POSITION_EXT),
    ENUM_MAPPING(GL_CURRENT_BINORMAL_EXT),
    ENUM_MAPPING(GL_CURRENT_BIT),
    ENUM_MAPPING(GL_CURRENT_COLOR),
    ENUM_MAPPING(GL_CURRENT_FOG_COORDINATE),
    ENUM_MAPPING(GL_CURRENT_INDEX),
    ENUM_MAPPING(GL_CURRENT_MATRIX_ARB),
    ENUM_MAPPING(GL_CURRENT_MATRIX_INDEX_ARB),
    ENUM_MAPPING(GL_CURRENT_MATRIX_STACK_DEPTH_ARB),
    ENUM_MAPPING(GL_CURRENT_NORMAL),
    ENUM_MAPPING(GL_CURRENT_PALETTE_MATRIX_ARB),
    ENUM_MAPPING(GL_CURRENT_PROGRAM),
    ENUM_MAPPING(GL_CURRENT_QUERY),
    ENUM_MAPPING(GL_CURRENT_RASTER_COLOR),
    ENUM_MAPPING(GL_CURRENT_RASTER_DISTANCE),
    ENUM_MAPPING(GL_CURRENT_RASTER_INDEX),
    ENUM_MAPPING(GL_CURRENT_RASTER_NORMAL_SGIX),
    ENUM_MAPPING(GL_CURRENT_RASTER_POSITION),
    ENUM_MAPPING(GL_CURRENT_RASTER_POSITION_VALID),
    ENUM_MAPPING(GL_CURRENT_RASTER_SECONDARY_COLOR),
    ENUM_MAPPING(GL_CURRENT_RASTER_TEXTURE_COORDS),
    ENUM_MAPPING(GL_CURRENT_SECONDARY_COLOR),
    ENUM_MAPPING(GL_CURRENT_TANGENT_EXT),
    ENUM_MAPPING(GL_CURRENT_TEXTURE_COORDS),
    ENUM_MAPPING(GL_CURRENT_VERTEX_ATTRIB),
    ENUM_MAPPING(GL_CURRENT_VERTEX_EXT),
    ENUM_MAPPING(GL_CURRENT_WEIGHT_ARB),
    ENUM_MAPPING(GL_CW),
    ENUM_MAPPING(GL_DECAL),
    ENUM_MAPPING(GL_DECR),
    ENUM_MAPPING(GL_DECR_WRAP),
    ENUM_MAPPING(GL_DEFORMATIONS_MASK_SGIX),
    ENUM_MAPPING(GL_DELETE_STATUS),
    ENUM_MAPPING(GL_DEPTH),
    ENUM_MAPPING(GL_DEPTH_ATTACHMENT_EXT),
    ENUM_MAPPING(GL_DEPTH_BIAS),
    ENUM_MAPPING(GL_DEPTH_BITS),
    ENUM_MAPPING(GL_DEPTH_BOUNDS_EXT),
    ENUM_MAPPING(GL_DEPTH_BOUNDS_TEST_EXT),
    ENUM_MAPPING(GL_DEPTH_BUFFER_BIT),
    ENUM_MAPPING(GL_DEPTH_CLEAR_VALUE),
    ENUM_MAPPING(GL_DEPTH_COMPONENT),
    ENUM_MAPPING(GL_DEPTH_COMPONENT16),
    ENUM_MAPPING(GL_DEPTH_COMPONENT24),
    ENUM_MAPPING(GL_DEPTH_FUNC),
    ENUM_MAPPING(GL_DEPTH_PASS_INSTRUMENT_COUNTERS_SGIX),
    ENUM_MAPPING(GL_DEPTH_PASS_INSTRUMENT_MAX_SGIX),
    ENUM_MAPPING(GL_DEPTH_PASS_INSTRUMENT_SGIX),
    ENUM_MAPPING(GL_DEPTH_RANGE),
    ENUM_MAPPING(GL_DEPTH_SCALE),
    ENUM_MAPPING(GL_DEPTH_STENCIL_EXT),
    ENUM_MAPPING(GL_DEPTH_TEST),
    ENUM_MAPPING(GL_DEPTH_TEXTURE_MODE),
    ENUM_MAPPING(GL_DEPTH_WRITEMASK),
    ENUM_MAPPING(GL_DEPTH24_STENCIL8_EXT),
    ENUM_MAPPING(GL_DETAIL_TEXTURE_2D_BINDING_SGIS),
    ENUM_MAPPING(GL_DETAIL_TEXTURE_2D_SGIS),
    ENUM_MAPPING(GL_DETAIL_TEXTURE_FUNC_POINTS_SGIS),
    ENUM_MAPPING(GL_DETAIL_TEXTURE_LEVEL_SGIS),
    ENUM_MAPPING(GL_DETAIL_TEXTURE_MODE_SGIS),
    ENUM_MAPPING(GL_DIFFUSE),
    ENUM_MAPPING(GL_DISTANCE_ATTENUATION_EXT),
    ENUM_MAPPING(GL_DISTANCE_ATTENUATION_SGIS),
    ENUM_MAPPING(GL_DITHER),
    ENUM_MAPPING(GL_DOMAIN),
    ENUM_MAPPING(GL_DONT_CARE),
    ENUM_MAPPING(GL_DOT3_RGB_ARB),
    ENUM_MAPPING(GL_DOT3_RGB_EXT),
    ENUM_MAPPING(GL_DOT3_RGBA),
    ENUM_MAPPING(GL_DOUBLE),
    ENUM_MAPPING(GL_DOUBLEBUFFER),
    ENUM_MAPPING(GL_DRAW_BUFFER),
    ENUM_MAPPING(GL_DRAW_BUFFER0),
    ENUM_MAPPING(GL_DRAW_BUFFER10),
    ENUM_MAPPING(GL_DRAW_BUFFER11),
    ENUM_MAPPING(GL_DRAW_BUFFER12),
    ENUM_MAPPING(GL_DRAW_BUFFER13),
    ENUM_MAPPING(GL_DRAW_BUFFER14),
    ENUM_MAPPING(GL_DRAW_BUFFER15),
    ENUM_MAPPING(GL_DRAW_BUFFER2),
    ENUM_MAPPING(GL_DRAW_BUFFER3),
    ENUM_MAPPING(GL_DRAW_BUFFER4),
    ENUM_MAPPING(GL_DRAW_BUFFER5),
    ENUM_MAPPING(GL_DRAW_BUFFER6),
    ENUM_MAPPING(GL_DRAW_BUFFER7),
    ENUM_MAPPING(GL_DRAW_BUFFER8),
    ENUM_MAPPING(GL_DRAW_BUFFER9),
    ENUM_MAPPING(GL_DRAW_FRAMEBUFFER_BINDING_EXT),
    ENUM_MAPPING(GL_DRAW_FRAMEBUFFER_EXT),
    ENUM_MAPPING(GL_DRAW_PIXEL_TOKEN),
    ENUM_MAPPING(GL_DRAW_PIXELS_APPLE),
    ENUM_MAPPING(GL_DST_ALPHA),
    ENUM_MAPPING(GL_DST_COLOR),
    ENUM_MAPPING(GL_DUAL_ALPHA12_SGIS),
    ENUM_MAPPING(GL_DUAL_ALPHA16_SGIS),
    ENUM_MAPPING(GL_DUAL_ALPHA4_SGIS),
    ENUM_MAPPING(GL_DUAL_ALPHA8_SGIS),
    ENUM_MAPPING(GL_DUAL_INTENSITY12_SGIS),
    ENUM_MAPPING(GL_DUAL_INTENSITY16_SGIS),
    ENUM_MAPPING(GL_DUAL_INTENSITY4_SGIS),
    ENUM_MAPPING(GL_DUAL_INTENSITY8_SGIS),
    ENUM_MAPPING(GL_DUAL_LUMINANCE_ALPHA4_SGIS),
    ENUM_MAPPING(GL_DUAL_LUMINANCE_ALPHA8_SGIS),
    ENUM_MAPPING(GL_DUAL_LUMINANCE12_SGIS),
    ENUM_MAPPING(GL_DUAL_LUMINANCE16_SGIS),
    ENUM_MAPPING(GL_DUAL_LUMINANCE4_SGIS),
    ENUM_MAPPING(GL_DUAL_LUMINANCE8_SGIS),
    ENUM_MAPPING(GL_DUAL_TEXTURE_SELECT_SGIS),
    ENUM_MAPPING(GL_DYNAMIC_COPY),
    ENUM_MAPPING(GL_DYNAMIC_DRAW),
    ENUM_MAPPING(GL_DYNAMIC_READ),
    ENUM_MAPPING(GL_EDGE_FLAG),
    ENUM_MAPPING(GL_EDGE_FLAG_ARRAY),
    ENUM_MAPPING(GL_EDGE_FLAG_ARRAY_BUFFER_BINDING),
    ENUM_MAPPING(GL_EDGE_FLAG_ARRAY_COUNT_EXT),
    ENUM_MAPPING(GL_EDGE_FLAG_ARRAY_EXT),
    ENUM_MAPPING(GL_EDGE_FLAG_ARRAY_LIST_IBM),
    ENUM_MAPPING(GL_EDGE_FLAG_ARRAY_LIST_STRIDE_IBM),
    ENUM_MAPPING(GL_EDGE_FLAG_ARRAY_POINTER),
    ENUM_MAPPING(GL_EDGE_FLAG_ARRAY_POINTER_EXT),
    ENUM_MAPPING(GL_EDGE_FLAG_ARRAY_STRIDE),
    ENUM_MAPPING(GL_EDGE_FLAG_ARRAY_STRIDE_EXT),
    ENUM_MAPPING(GL_EDGEFLAG_BIT_PGI),
    ENUM_MAPPING(GL_ELEMENT_ARRAY_APPLE),
    ENUM_MAPPING(GL_ELEMENT_ARRAY_BUFFER_BINDING),
    ENUM_MAPPING(GL_ELEMENT_ARRAY_POINTER_APPLE),
    ENUM_MAPPING(GL_ELEMENT_ARRAY_TYPE_APPLE),
    ENUM_MAPPING(GL_EMISSION),
    ENUM_MAPPING(GL_ENABLE_BIT),
    ENUM_MAPPING(GL_EQUAL),
    ENUM_MAPPING(GL_EQUIV),
    ENUM_MAPPING(GL_EVAL_BIT),
    ENUM_MAPPING(GL_EXP),
    ENUM_MAPPING(GL_EXP2),
    ENUM_MAPPING(GL_EXTENSIONS),
    ENUM_MAPPING(GL_EYE_DISTANCE_TO_LINE_SGIS),
    ENUM_MAPPING(GL_EYE_DISTANCE_TO_POINT_SGIS),
    ENUM_MAPPING(GL_EYE_LINE_SGIS),
    ENUM_MAPPING(GL_EYE_LINEAR),
    ENUM_MAPPING(GL_EYE_PLANE),
    ENUM_MAPPING(GL_EYE_POINT_SGIS),
    ENUM_MAPPING(GL_FALSE),
    ENUM_MAPPING(GL_FASTEST),
    ENUM_MAPPING(GL_FEEDBACK),
    ENUM_MAPPING(GL_FEEDBACK_BUFFER_POINTER),
    ENUM_MAPPING(GL_FEEDBACK_BUFFER_SIZE),
    ENUM_MAPPING(GL_FEEDBACK_BUFFER_TYPE),
    ENUM_MAPPING(GL_FENCE_APPLE),
    ENUM_MAPPING(GL_FILL),
    ENUM_MAPPING(GL_FILTER4_SGIS),
    ENUM_MAPPING(GL_FIXED_ONLY_ARB),
    ENUM_MAPPING(GL_FLAT),
    ENUM_MAPPING(GL_FLOAT),
    ENUM_MAPPING(GL_FLOAT_VEC2),
    ENUM_MAPPING(GL_FLOAT_VEC3),
    ENUM_MAPPING(GL_FLOAT_VEC4),
    ENUM_MAPPING(GL_FOG),
    ENUM_MAPPING(GL_FOG_BIT),
    ENUM_MAPPING(GL_FOG_COLOR),
    ENUM_MAPPING(GL_FOG_COORD_ARRAY_BUFFER_BINDING),
    ENUM_MAPPING(GL_FOG_COORD_ARRAY_POINTER),
    ENUM_MAPPING(GL_FOG_COORD_ARRAY_STRIDE),
    ENUM_MAPPING(GL_FOG_COORD_ARRAY_TYPE),
    ENUM_MAPPING(GL_FOG_COORD_SRC),
    ENUM_MAPPING(GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING),
    ENUM_MAPPING(GL_FOG_COORDINATE_ARRAY_LIST_IBM),
    ENUM_MAPPING(GL_FOG_COORDINATE_ARRAY_LIST_STRIDE_IBM),
    ENUM_MAPPING(GL_FOG_COORDINATE_ARRAY_POINTER_EXT),
    ENUM_MAPPING(GL_FOG_COORDINATE_ARRAY_STRIDE_EXT),
    ENUM_MAPPING(GL_FOG_COORDINATE_ARRAY_TYPE_EXT),
    ENUM_MAPPING(GL_FOG_COORDINATE_SOURCE),
    ENUM_MAPPING(GL_FOG_DENSITY),
    ENUM_MAPPING(GL_FOG_END),
    ENUM_MAPPING(GL_FOG_FUNC_POINTS_SGIS),
    ENUM_MAPPING(GL_FOG_FUNC_SGIS),
    ENUM_MAPPING(GL_FOG_HINT),
    ENUM_MAPPING(GL_FOG_INDEX),
    ENUM_MAPPING(GL_FOG_MODE),
    ENUM_MAPPING(GL_FOG_OFFSET_SGIX),
    ENUM_MAPPING(GL_FOG_OFFSET_VALUE_SGIX),
    ENUM_MAPPING(GL_FOG_SCALE_SGIX),
    ENUM_MAPPING(GL_FOG_SCALE_VALUE_SGIX),
    ENUM_MAPPING(GL_FOG_SPECULAR_TEXTURE_WIN),
    ENUM_MAPPING(GL_FOG_START),
    ENUM_MAPPING(GL_FORMAT_SUBSAMPLE_24_24_OML),
    ENUM_MAPPING(GL_FORMAT_SUBSAMPLE_244_244_OML),
    ENUM_MAPPING(GL_FRAGMENT_COLOR_EXT),
    ENUM_MAPPING(GL_FRAGMENT_COLOR_MATERIAL_FACE_SGIX),
    ENUM_MAPPING(GL_FRAGMENT_COLOR_MATERIAL_PARAMETER_SGIX),
    ENUM_MAPPING(GL_FRAGMENT_COLOR_MATERIAL_SGIX),
    ENUM_MAPPING(GL_FRAGMENT_DEPTH_EXT),
    ENUM_MAPPING(GL_FRAGMENT_LIGHT_MODEL_AMBIENT_SGIX),
    ENUM_MAPPING(GL_FRAGMENT_LIGHT_MODEL_LOCAL_VIEWER_SGIX),
    ENUM_MAPPING(GL_FRAGMENT_LIGHT_MODEL_NORMAL_INTERPOLATION_SGIX),
    ENUM_MAPPING(GL_FRAGMENT_LIGHT_MODEL_TWO_SIDE_SGIX),
    ENUM_MAPPING(GL_FRAGMENT_LIGHT0_SGIX),
    ENUM_MAPPING(GL_FRAGMENT_LIGHT1_SGIX),
    ENUM_MAPPING(GL_FRAGMENT_LIGHT2_SGIX),
    ENUM_MAPPING(GL_FRAGMENT_LIGHT3_SGIX),
    ENUM_MAPPING(GL_FRAGMENT_LIGHT4_SGIX),
    ENUM_MAPPING(GL_FRAGMENT_LIGHT5_SGIX),
    ENUM_MAPPING(GL_FRAGMENT_LIGHT6_SGIX),
    ENUM_MAPPING(GL_FRAGMENT_LIGHT7_SGIX),
    ENUM_MAPPING(GL_FRAGMENT_LIGHTING_SGIX),
    ENUM_MAPPING(GL_FRAGMENT_MATERIAL_EXT),
    ENUM_MAPPING(GL_FRAGMENT_NORMAL_EXT),
    ENUM_MAPPING(GL_FRAGMENT_PROGRAM_ARB),
    ENUM_MAPPING(GL_FRAGMENT_SHADER_ARB),
    ENUM_MAPPING(GL_FRAGMENT_SHADER_DERIVATIVE_HINT_ARB),
    ENUM_MAPPING(GL_FRAMEBUFFER_ATTACHMENT_LAYERED_EXT),
    ENUM_MAPPING(GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME_EXT),
    ENUM_MAPPING(GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE_EXT),
    ENUM_MAPPING(GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_3D_ZOFFSET_EXT),
    ENUM_MAPPING(GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE_EXT),
    ENUM_MAPPING(GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER_EXT),
    ENUM_MAPPING(GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL_EXT),
    ENUM_MAPPING(GL_FRAMEBUFFER_BINDING_EXT),
    ENUM_MAPPING(GL_FRAMEBUFFER_COMPLETE_EXT),
    ENUM_MAPPING(GL_FRAMEBUFFER_EXT),
    ENUM_MAPPING(GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT_EXT),
    ENUM_MAPPING(GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS_EXT),
    ENUM_MAPPING(GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER_EXT),
    ENUM_MAPPING(GL_FRAMEBUFFER_INCOMPLETE_FORMATS_EXT),
    ENUM_MAPPING(GL_FRAMEBUFFER_INCOMPLETE_LAYER_COUNT_EXT),
    ENUM_MAPPING(GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS_EXT),
    ENUM_MAPPING(GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT_EXT),
    ENUM_MAPPING(GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_EXT),
    ENUM_MAPPING(GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER_EXT),
    ENUM_MAPPING(GL_FRAMEBUFFER_SRGB_CAPABLE_EXT),
    ENUM_MAPPING(GL_FRAMEBUFFER_SRGB_EXT),
    ENUM_MAPPING(GL_FRAMEBUFFER_UNSUPPORTED_EXT),
    ENUM_MAPPING(GL_FRAMEZOOM_FACTOR_SGIX),
    ENUM_MAPPING(GL_FRAMEZOOM_SGIX),
    ENUM_MAPPING(GL_FRONT),
    ENUM_MAPPING(GL_FRONT_AND_BACK),
    ENUM_MAPPING(GL_FRONT_FACE),
    ENUM_MAPPING(GL_FRONT_LEFT),
    ENUM_MAPPING(GL_FRONT_RIGHT),
    ENUM_MAPPING(GL_FULL_RANGE_EXT),
    ENUM_MAPPING(GL_FULL_STIPPLE_HINT_PGI),
    ENUM_MAPPING(GL_FUNC_ADD),
    ENUM_MAPPING(GL_FUNC_REVERSE_SUBTRACT),
    ENUM_MAPPING(GL_FUNC_SUBTRACT),
    ENUM_MAPPING(GL_GENERATE_MIPMAP_HINT),
    ENUM_MAPPING(GL_GENERATE_MIPMAP_SGIS),
    ENUM_MAPPING(GL_GEOMETRY_DEFORMATION_BIT_SGIX),
    ENUM_MAPPING(GL_GEOMETRY_DEFORMATION_SGIX),
    ENUM_MAPPING(GL_GEOMETRY_INPUT_TYPE_EXT),
    ENUM_MAPPING(GL_GEOMETRY_OUTPUT_TYPE_EXT),
    ENUM_MAPPING(GL_GEOMETRY_SHADER_EXT),
    ENUM_MAPPING(GL_GEOMETRY_VERTICES_OUT_EXT),
    ENUM_MAPPING(GL_GEQUAL),
    ENUM_MAPPING(GL_GLOBAL_ALPHA_FACTOR_SUN),
    ENUM_MAPPING(GL_GLOBAL_ALPHA_SUN),
    ENUM_MAPPING(GL_GREATER),
    ENUM_MAPPING(GL_GREEN),
    ENUM_MAPPING(GL_GREEN_BIAS),
    ENUM_MAPPING(GL_GREEN_BITS),
    ENUM_MAPPING(GL_GREEN_INTEGER_EXT),
    ENUM_MAPPING(GL_GREEN_MAX_CLAMP_INGR),
    ENUM_MAPPING(GL_GREEN_MIN_CLAMP_INGR),
    ENUM_MAPPING(GL_GREEN_SCALE),
    ENUM_MAPPING(GL_HALF_FLOAT_ARB),
    ENUM_MAPPING(GL_HINT_BIT),
    ENUM_MAPPING(GL_HISTOGRAM_ALPHA_SIZE),
    ENUM_MAPPING(GL_HISTOGRAM_BLUE_SIZE),
    ENUM_MAPPING(GL_HISTOGRAM_EXT),
    ENUM_MAPPING(GL_HISTOGRAM_FORMAT),
    ENUM_MAPPING(GL_HISTOGRAM_GREEN_SIZE),
    ENUM_MAPPING(GL_HISTOGRAM_LUMINANCE_SIZE),
    ENUM_MAPPING(GL_HISTOGRAM_RED_SIZE),
    ENUM_MAPPING(GL_HISTOGRAM_SINK),
    ENUM_MAPPING(GL_HISTOGRAM_WIDTH),
    ENUM_MAPPING(GL_IGNORE_BORDER_HP),
    ENUM_MAPPING(GL_IMAGE_CUBIC_WEIGHT_HP),
    ENUM_MAPPING(GL_IMAGE_MAG_FILTER_HP),
    ENUM_MAPPING(GL_IMAGE_MIN_FILTER_HP),
    ENUM_MAPPING(GL_IMAGE_ROTATE_ANGLE_HP),
    ENUM_MAPPING(GL_IMAGE_ROTATE_ORIGIN_X_HP),
    ENUM_MAPPING(GL_IMAGE_ROTATE_ORIGIN_Y_HP),
    ENUM_MAPPING(GL_IMAGE_SCALE_X_HP),
    ENUM_MAPPING(GL_IMAGE_SCALE_Y_HP),
    ENUM_MAPPING(GL_IMAGE_TRANSFORM_2D_HP),
    ENUM_MAPPING(GL_IMAGE_TRANSLATE_X_HP),
    ENUM_MAPPING(GL_IMAGE_TRANSLATE_Y_HP),
    ENUM_MAPPING(GL_IMPLEMENTATION_COLOR_READ_FORMAT_OES),
    ENUM_MAPPING(GL_IMPLEMENTATION_COLOR_READ_TYPE_OES),
    ENUM_MAPPING(GL_INCR),
    ENUM_MAPPING(GL_INCR_WRAP),
    ENUM_MAPPING(GL_INDEX_ARRAY),
    ENUM_MAPPING(GL_INDEX_ARRAY_BUFFER_BINDING),
    ENUM_MAPPING(GL_INDEX_ARRAY_COUNT_EXT),
    ENUM_MAPPING(GL_INDEX_ARRAY_EXT),
    ENUM_MAPPING(GL_INDEX_ARRAY_LIST_IBM),
    ENUM_MAPPING(GL_INDEX_ARRAY_LIST_STRIDE_IBM),
    ENUM_MAPPING(GL_INDEX_ARRAY_POINTER),
    ENUM_MAPPING(GL_INDEX_ARRAY_POINTER_EXT),
    ENUM_MAPPING(GL_INDEX_ARRAY_STRIDE),
    ENUM_MAPPING(GL_INDEX_ARRAY_STRIDE_EXT),
    ENUM_MAPPING(GL_INDEX_ARRAY_TYPE),
    ENUM_MAPPING(GL_INDEX_ARRAY_TYPE_EXT),
    ENUM_MAPPING(GL_INDEX_BIT_PGI),
    ENUM_MAPPING(GL_INDEX_BITS),
    ENUM_MAPPING(GL_INDEX_CLEAR_VALUE),
    ENUM_MAPPING(GL_INDEX_LOGIC_OP),
    ENUM_MAPPING(GL_INDEX_MATERIAL_EXT),
    ENUM_MAPPING(GL_INDEX_MATERIAL_FACE_EXT),
    ENUM_MAPPING(GL_INDEX_MATERIAL_PARAMETER_EXT),
    ENUM_MAPPING(GL_INDEX_MODE),
    ENUM_MAPPING(GL_INDEX_OFFSET),
    ENUM_MAPPING(GL_INDEX_SHIFT),
    ENUM_MAPPING(GL_INDEX_TEST_EXT),
    ENUM_MAPPING(GL_INDEX_TEST_FUNC_EXT),
    ENUM_MAPPING(GL_INDEX_TEST_REF_EXT),
    ENUM_MAPPING(GL_INDEX_WRITEMASK),
    ENUM_MAPPING(GL_INFO_LOG_LENGTH),
    ENUM_MAPPING(GL_INSTRUMENT_BUFFER_POINTER_SGIX),
    ENUM_MAPPING(GL_INSTRUMENT_MEASUREMENTS_SGIX),
    ENUM_MAPPING(GL_INT),
    ENUM_MAPPING(GL_INT_SAMPLER_1D_ARRAY_EXT),
    ENUM_MAPPING(GL_INT_SAMPLER_1D_EXT),
    ENUM_MAPPING(GL_INT_SAMPLER_2D_ARRAY_EXT),
    ENUM_MAPPING(GL_INT_SAMPLER_2D_EXT),
    ENUM_MAPPING(GL_INT_SAMPLER_2D_RECT_EXT),
    ENUM_MAPPING(GL_INT_SAMPLER_3D_EXT),
    ENUM_MAPPING(GL_INT_SAMPLER_BUFFER_EXT),
    ENUM_MAPPING(GL_INT_SAMPLER_CUBE_EXT),
    ENUM_MAPPING(GL_INT_VEC2),
    ENUM_MAPPING(GL_INT_VEC3),
    ENUM_MAPPING(GL_INT_VEC4),
    ENUM_MAPPING(GL_INTENSITY),
    ENUM_MAPPING(GL_INTENSITY_EXT),
    ENUM_MAPPING(GL_INTENSITY12),
    ENUM_MAPPING(GL_INTENSITY16),
    ENUM_MAPPING(GL_INTENSITY16F_ARB),
    ENUM_MAPPING(GL_INTENSITY16I_EXT),
    ENUM_MAPPING(GL_INTENSITY16UI_EXT),
    ENUM_MAPPING(GL_INTENSITY32F_ARB),
    ENUM_MAPPING(GL_INTENSITY32I_EXT),
    ENUM_MAPPING(GL_INTENSITY32UI_EXT),
    ENUM_MAPPING(GL_INTENSITY4),
    ENUM_MAPPING(GL_INTENSITY8),
    ENUM_MAPPING(GL_INTENSITY8I_EXT),
    ENUM_MAPPING(GL_INTENSITY8UI_EXT),
    ENUM_MAPPING(GL_INTERLACE_OML),
    ENUM_MAPPING(GL_INTERLACE_READ_INGR),
    ENUM_MAPPING(GL_INTERLACE_READ_OML),
    ENUM_MAPPING(GL_INTERLACE_SGIX),
    ENUM_MAPPING(GL_INTERPOLATE),
    ENUM_MAPPING(GL_INVALID_ENUM),
    ENUM_MAPPING(GL_INVALID_FRAMEBUFFER_OPERATION_EXT),
    ENUM_MAPPING(GL_INVALID_OPERATION),
    ENUM_MAPPING(GL_INVALID_VALUE),
    ENUM_MAPPING(GL_INVARIANT_DATATYPE_EXT),
    ENUM_MAPPING(GL_INVARIANT_EXT),
    ENUM_MAPPING(GL_INVARIANT_VALUE_EXT),
    ENUM_MAPPING(GL_INVERT),
    ENUM_MAPPING(GL_INVERTED_SCREEN_W_REND),
    ENUM_MAPPING(GL_IR_INSTRUMENT1_SGIX),
    ENUM_MAPPING(GL_IUI_N3F_V2F_EXT),
    ENUM_MAPPING(GL_IUI_N3F_V3F_EXT),
    ENUM_MAPPING(GL_IUI_V2F_EXT),
    ENUM_MAPPING(GL_IUI_V3F_EXT),
    ENUM_MAPPING(GL_KEEP),
    ENUM_MAPPING(GL_LEFT),
    ENUM_MAPPING(GL_LEQUAL),
    ENUM_MAPPING(GL_LESS),
    ENUM_MAPPING(GL_LIGHT_ENV_MODE_SGIX),
    ENUM_MAPPING(GL_LIGHT_MODEL_AMBIENT),
    ENUM_MAPPING(GL_LIGHT_MODEL_COLOR_CONTROL_EXT),
    ENUM_MAPPING(GL_LIGHT_MODEL_LOCAL_VIEWER),
    ENUM_MAPPING(GL_LIGHT_MODEL_SPECULAR_VECTOR_APPLE),
    ENUM_MAPPING(GL_LIGHT_MODEL_TWO_SIDE),
    ENUM_MAPPING(GL_LIGHT0),
    ENUM_MAPPING(GL_LIGHT1),
    ENUM_MAPPING(GL_LIGHT2),
    ENUM_MAPPING(GL_LIGHT3),
    ENUM_MAPPING(GL_LIGHT4),
    ENUM_MAPPING(GL_LIGHT5),
    ENUM_MAPPING(GL_LIGHT6),
    ENUM_MAPPING(GL_LIGHT7),
    ENUM_MAPPING(GL_LIGHTING),
    ENUM_MAPPING(GL_LIGHTING_BIT),
    ENUM_MAPPING(GL_LINE),
    ENUM_MAPPING(GL_LINE_BIT),
    ENUM_MAPPING(GL_LINE_LOOP),
    ENUM_MAPPING(GL_LINE_RESET_TOKEN),
    ENUM_MAPPING(GL_LINE_SMOOTH),
    ENUM_MAPPING(GL_LINE_SMOOTH_HINT),
    ENUM_MAPPING(GL_LINE_STIPPLE),
    ENUM_MAPPING(GL_LINE_STIPPLE_PATTERN),
    ENUM_MAPPING(GL_LINE_STIPPLE_REPEAT),
    ENUM_MAPPING(GL_LINE_STRIP),
    ENUM_MAPPING(GL_LINE_STRIP_ADJACENCY_EXT),
    ENUM_MAPPING(GL_LINE_TOKEN),
    ENUM_MAPPING(GL_LINE_WIDTH),
    ENUM_MAPPING(GL_LINE_WIDTH_GRANULARITY),
    ENUM_MAPPING(GL_LINE_WIDTH_RANGE),
    ENUM_MAPPING(GL_LINEAR),
    ENUM_MAPPING(GL_LINEAR_ATTENUATION),
    ENUM_MAPPING(GL_LINEAR_CLIPMAP_LINEAR_SGIX),
    ENUM_MAPPING(GL_LINEAR_CLIPMAP_NEAREST_SGIX),
    ENUM_MAPPING(GL_LINEAR_DETAIL_ALPHA_SGIS),
    ENUM_MAPPING(GL_LINEAR_DETAIL_COLOR_SGIS),
    ENUM_MAPPING(GL_LINEAR_DETAIL_SGIS),
    ENUM_MAPPING(GL_LINEAR_MIPMAP_LINEAR),
    ENUM_MAPPING(GL_LINEAR_MIPMAP_NEAREST),
    ENUM_MAPPING(GL_LINEAR_SHARPEN_ALPHA_SGIS),
    ENUM_MAPPING(GL_LINEAR_SHARPEN_COLOR_SGIS),
    ENUM_MAPPING(GL_LINEAR_SHARPEN_SGIS),
    ENUM_MAPPING(GL_LINES),
    ENUM_MAPPING(GL_LINES_ADJACENCY_EXT),
    ENUM_MAPPING(GL_LINK_STATUS),
    ENUM_MAPPING(GL_LIST_BASE),
    ENUM_MAPPING(GL_LIST_BIT),
    ENUM_MAPPING(GL_LIST_INDEX),
    ENUM_MAPPING(GL_LIST_MODE),
    ENUM_MAPPING(GL_LIST_PRIORITY_SGIX),
    ENUM_MAPPING(GL_LOAD),
    ENUM_MAPPING(GL_LOCAL_CONSTANT_DATATYPE_EXT),
    ENUM_MAPPING(GL_LOCAL_CONSTANT_EXT),
    ENUM_MAPPING(GL_LOCAL_CONSTANT_VALUE_EXT),
    ENUM_MAPPING(GL_LOCAL_EXT),
    ENUM_MAPPING(GL_LOGIC_OP),
    ENUM_MAPPING(GL_LOGIC_OP_MODE),
    ENUM_MAPPING(GL_LOWER_LEFT),
    ENUM_MAPPING(GL_LUMINANCE),
    ENUM_MAPPING(GL_LUMINANCE_ALPHA),
    ENUM_MAPPING(GL_LUMINANCE_ALPHA_INTEGER_EXT),
    ENUM_MAPPING(GL_LUMINANCE_ALPHA16F_ARB),
    ENUM_MAPPING(GL_LUMINANCE_ALPHA16I_EXT),
    ENUM_MAPPING(GL_LUMINANCE_ALPHA16UI_EXT),
    ENUM_MAPPING(GL_LUMINANCE_ALPHA32F_ARB),
    ENUM_MAPPING(GL_LUMINANCE_ALPHA32I_EXT),
    ENUM_MAPPING(GL_LUMINANCE_ALPHA32UI_EXT),
    ENUM_MAPPING(GL_LUMINANCE_ALPHA8I_EXT),
    ENUM_MAPPING(GL_LUMINANCE_ALPHA8UI_EXT),
    ENUM_MAPPING(GL_LUMINANCE_INTEGER_EXT),
    ENUM_MAPPING(GL_LUMINANCE12),
    ENUM_MAPPING(GL_LUMINANCE12_ALPHA12),
    ENUM_MAPPING(GL_LUMINANCE12_ALPHA12_EXT),
    ENUM_MAPPING(GL_LUMINANCE12_ALPHA4),
    ENUM_MAPPING(GL_LUMINANCE12_ALPHA4_EXT),
    ENUM_MAPPING(GL_LUMINANCE12_EXT),
    ENUM_MAPPING(GL_LUMINANCE16),
    ENUM_MAPPING(GL_LUMINANCE16_ALPHA16),
    ENUM_MAPPING(GL_LUMINANCE16_ALPHA16_EXT),
    ENUM_MAPPING(GL_LUMINANCE16_EXT),
    ENUM_MAPPING(GL_LUMINANCE16F_ARB),
    ENUM_MAPPING(GL_LUMINANCE16I_EXT),
    ENUM_MAPPING(GL_LUMINANCE16UI_EXT),
    ENUM_MAPPING(GL_LUMINANCE32F_ARB),
    ENUM_MAPPING(GL_LUMINANCE32I_EXT),
    ENUM_MAPPING(GL_LUMINANCE32UI_EXT),
    ENUM_MAPPING(GL_LUMINANCE4),
    ENUM_MAPPING(GL_LUMINANCE4_ALPHA4),
    ENUM_MAPPING(GL_LUMINANCE4_ALPHA4_EXT),
    ENUM_MAPPING(GL_LUMINANCE4_EXT),
    ENUM_MAPPING(GL_LUMINANCE6_ALPHA2),
    ENUM_MAPPING(GL_LUMINANCE6_ALPHA2_EXT),
    ENUM_MAPPING(GL_LUMINANCE8),
    ENUM_MAPPING(GL_LUMINANCE8_ALPHA8),
    ENUM_MAPPING(GL_LUMINANCE8_ALPHA8_EXT),
    ENUM_MAPPING(GL_LUMINANCE8_EXT),
    ENUM_MAPPING(GL_LUMINANCE8I_EXT),
    ENUM_MAPPING(GL_LUMINANCE8UI_EXT),
    ENUM_MAPPING(GL_MAP_COLOR),
    ENUM_MAPPING(GL_MAP_STENCIL),
    ENUM_MAPPING(GL_MAP1_BINORMAL_EXT),
    ENUM_MAPPING(GL_MAP1_COLOR_4),
    ENUM_MAPPING(GL_MAP1_GRID_DOMAIN),
    ENUM_MAPPING(GL_MAP1_GRID_SEGMENTS),
    ENUM_MAPPING(GL_MAP1_INDEX),
    ENUM_MAPPING(GL_MAP1_NORMAL),
    ENUM_MAPPING(GL_MAP1_TANGENT_EXT),
    ENUM_MAPPING(GL_MAP1_TEXTURE_COORD_1),
    ENUM_MAPPING(GL_MAP1_TEXTURE_COORD_2),
    ENUM_MAPPING(GL_MAP1_TEXTURE_COORD_3),
    ENUM_MAPPING(GL_MAP1_TEXTURE_COORD_4),
    ENUM_MAPPING(GL_MAP1_VERTEX_3),
    ENUM_MAPPING(GL_MAP1_VERTEX_4),
    ENUM_MAPPING(GL_MAP2_BINORMAL_EXT),
    ENUM_MAPPING(GL_MAP2_COLOR_4),
    ENUM_MAPPING(GL_MAP2_GRID_DOMAIN),
    ENUM_MAPPING(GL_MAP2_GRID_SEGMENTS),
    ENUM_MAPPING(GL_MAP2_INDEX),
    ENUM_MAPPING(GL_MAP2_NORMAL),
    ENUM_MAPPING(GL_MAP2_TANGENT_EXT),
    ENUM_MAPPING(GL_MAP2_TEXTURE_COORD_1),
    ENUM_MAPPING(GL_MAP2_TEXTURE_COORD_2),
    ENUM_MAPPING(GL_MAP2_TEXTURE_COORD_3),
    ENUM_MAPPING(GL_MAP2_TEXTURE_COORD_4),
    ENUM_MAPPING(GL_MAP2_VERTEX_3),
    ENUM_MAPPING(GL_MAP2_VERTEX_4),
    ENUM_MAPPING(GL_MAT_AMBIENT_AND_DIFFUSE_BIT_PGI),
    ENUM_MAPPING(GL_MAT_AMBIENT_BIT_PGI),
    ENUM_MAPPING(GL_MAT_COLOR_INDEXES_BIT_PGI),
    ENUM_MAPPING(GL_MAT_DIFFUSE_BIT_PGI),
    ENUM_MAPPING(GL_MAT_EMISSION_BIT_PGI),
    ENUM_MAPPING(GL_MAT_SHININESS_BIT_PGI),
    ENUM_MAPPING(GL_MAT_SPECULAR_BIT_PGI),
    ENUM_MAPPING(GL_MATERIAL_SIDE_HINT_PGI),
    ENUM_MAPPING(GL_MATRIX_EXT),
    ENUM_MAPPING(GL_MATRIX_INDEX_ARRAY_ARB),
    ENUM_MAPPING(GL_MATRIX_INDEX_ARRAY_POINTER_ARB),
    ENUM_MAPPING(GL_MATRIX_INDEX_ARRAY_SIZE_ARB),
    ENUM_MAPPING(GL_MATRIX_INDEX_ARRAY_STRIDE_ARB),
    ENUM_MAPPING(GL_MATRIX_INDEX_ARRAY_TYPE_ARB),
    ENUM_MAPPING(GL_MATRIX_MODE),
    ENUM_MAPPING(GL_MATRIX_PALETTE_ARB),
    ENUM_MAPPING(GL_MATRIX0_ARB),
    ENUM_MAPPING(GL_MATRIX1_ARB),
    ENUM_MAPPING(GL_MATRIX10_ARB),
    ENUM_MAPPING(GL_MATRIX11_ARB),
    ENUM_MAPPING(GL_MATRIX12_ARB),
    ENUM_MAPPING(GL_MATRIX13_ARB),
    ENUM_MAPPING(GL_MATRIX14_ARB),
    ENUM_MAPPING(GL_MATRIX15_ARB),
    ENUM_MAPPING(GL_MATRIX16_ARB),
    ENUM_MAPPING(GL_MATRIX17_ARB),
    ENUM_MAPPING(GL_MATRIX18_ARB),
    ENUM_MAPPING(GL_MATRIX19_ARB),
    ENUM_MAPPING(GL_MATRIX2_ARB),
    ENUM_MAPPING(GL_MATRIX20_ARB),
    ENUM_MAPPING(GL_MATRIX21_ARB),
    ENUM_MAPPING(GL_MATRIX22_ARB),
    ENUM_MAPPING(GL_MATRIX23_ARB),
    ENUM_MAPPING(GL_MATRIX24_ARB),
    ENUM_MAPPING(GL_MATRIX25_ARB),
    ENUM_MAPPING(GL_MATRIX26_ARB),
    ENUM_MAPPING(GL_MATRIX27_ARB),
    ENUM_MAPPING(GL_MATRIX28_ARB),
    ENUM_MAPPING(GL_MATRIX29_ARB),
    ENUM_MAPPING(GL_MATRIX3_ARB),
    ENUM_MAPPING(GL_MATRIX30_ARB),
    ENUM_MAPPING(GL_MATRIX31_ARB),
    ENUM_MAPPING(GL_MATRIX4_ARB),
    ENUM_MAPPING(GL_MATRIX5_ARB),
    ENUM_MAPPING(GL_MATRIX6_ARB),
    ENUM_MAPPING(GL_MATRIX7_ARB),
    ENUM_MAPPING(GL_MATRIX8_ARB),
    ENUM_MAPPING(GL_MATRIX9_ARB),
    ENUM_MAPPING(GL_MAX_3D_TEXTURE_SIZE),
    ENUM_MAPPING(GL_MAX_4D_TEXTURE_SIZE_SGIS),
    ENUM_MAPPING(GL_MAX_ACTIVE_LIGHTS_SGIX),
    ENUM_MAPPING(GL_MAX_ARRAY_TEXTURE_LAYERS_EXT),
    ENUM_MAPPING(GL_MAX_ASYNC_DRAW_PIXELS_SGIX),
    ENUM_MAPPING(GL_MAX_ASYNC_HISTOGRAM_SGIX),
    ENUM_MAPPING(GL_MAX_ASYNC_READ_PIXELS_SGIX),
    ENUM_MAPPING(GL_MAX_ASYNC_TEX_IMAGE_SGIX),
    ENUM_MAPPING(GL_MAX_ATTRIB_STACK_DEPTH),
    ENUM_MAPPING(GL_MAX_BINDABLE_UNIFORM_SIZE_EXT),
    ENUM_MAPPING(GL_MAX_CLIENT_ATTRIB_STACK_DEPTH),
    ENUM_MAPPING(GL_MAX_CLIP_PLANES),
    ENUM_MAPPING(GL_MAX_CLIPMAP_DEPTH_SGIX),
    ENUM_MAPPING(GL_MAX_CLIPMAP_VIRTUAL_DEPTH_SGIX),
    ENUM_MAPPING(GL_MAX_COLOR_ATTACHMENTS_EXT),
    ENUM_MAPPING(GL_MAX_COLOR_MATRIX_STACK_DEPTH),
    ENUM_MAPPING(GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS),
    ENUM_MAPPING(GL_MAX_CONVOLUTION_HEIGHT),
    ENUM_MAPPING(GL_MAX_CONVOLUTION_WIDTH),
    ENUM_MAPPING(GL_MAX_CUBE_MAP_TEXTURE_SIZE),
    ENUM_MAPPING(GL_MAX_DEFORMATION_ORDER_SGIX),
    ENUM_MAPPING(GL_MAX_DRAW_BUFFERS),
    ENUM_MAPPING(GL_MAX_EVAL_ORDER),
    ENUM_MAPPING(GL_MAX_EXT),
    ENUM_MAPPING(GL_MAX_FOG_FUNC_POINTS_SGIS),
    ENUM_MAPPING(GL_MAX_FRAGMENT_BINDABLE_UNIFORMS_EXT),
    ENUM_MAPPING(GL_MAX_FRAGMENT_LIGHTS_SGIX),
    ENUM_MAPPING(GL_MAX_FRAGMENT_UNIFORM_COMPONENTS),
    ENUM_MAPPING(GL_MAX_FRAMEZOOM_FACTOR_SGIX),
    ENUM_MAPPING(GL_MAX_GEOMETRY_BINDABLE_UNIFORMS_EXT),
    ENUM_MAPPING(GL_MAX_GEOMETRY_OUTPUT_VERTICES_EXT),
    ENUM_MAPPING(GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS_EXT),
    ENUM_MAPPING(GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS_EXT),
    ENUM_MAPPING(GL_MAX_GEOMETRY_UNIFORM_COMPONENTS_EXT),
    ENUM_MAPPING(GL_MAX_GEOMETRY_VARYING_COMPONENTS_EXT),
    ENUM_MAPPING(GL_MAX_LIGHTS),
    ENUM_MAPPING(GL_MAX_LIST_NESTING),
    ENUM_MAPPING(GL_MAX_MATRIX_PALETTE_STACK_DEPTH_ARB),
    ENUM_MAPPING(GL_MAX_MODELVIEW_STACK_DEPTH),
    ENUM_MAPPING(GL_MAX_NAME_STACK_DEPTH),
    ENUM_MAPPING(GL_MAX_OPTIMIZED_VERTEX_SHADER_INSTRUCTIONS_EXT),
    ENUM_MAPPING(GL_MAX_OPTIMIZED_VERTEX_SHADER_INVARIANTS_EXT),
    ENUM_MAPPING(GL_MAX_OPTIMIZED_VERTEX_SHADER_LOCAL_CONSTANTS_EXT),
    ENUM_MAPPING(GL_MAX_OPTIMIZED_VERTEX_SHADER_LOCALS_EXT),
    ENUM_MAPPING(GL_MAX_OPTIMIZED_VERTEX_SHADER_VARIANTS_EXT),
    ENUM_MAPPING(GL_MAX_PALETTE_MATRICES_ARB),
    ENUM_MAPPING(GL_MAX_PIXEL_MAP_TABLE),
    ENUM_MAPPING(GL_MAX_PIXEL_TRANSFORM_2D_STACK_DEPTH_EXT),
    ENUM_MAPPING(GL_MAX_PROGRAM_ADDRESS_REGISTERS_ARB),
    ENUM_MAPPING(GL_MAX_PROGRAM_ALU_INSTRUCTIONS_ARB),
    ENUM_MAPPING(GL_MAX_PROGRAM_ATTRIBS_ARB),
    ENUM_MAPPING(GL_MAX_PROGRAM_ENV_PARAMETERS_ARB),
    ENUM_MAPPING(GL_MAX_PROGRAM_INSTRUCTIONS_ARB),
    ENUM_MAPPING(GL_MAX_PROGRAM_LOCAL_PARAMETERS_ARB),
    ENUM_MAPPING(GL_MAX_PROGRAM_MATRICES_ARB),
    ENUM_MAPPING(GL_MAX_PROGRAM_MATRIX_STACK_DEPTH_ARB),
    ENUM_MAPPING(GL_MAX_PROGRAM_NATIVE_ADDRESS_REGISTERS_ARB),
    ENUM_MAPPING(GL_MAX_PROGRAM_NATIVE_ALU_INSTRUCTIONS_ARB),
    ENUM_MAPPING(GL_MAX_PROGRAM_NATIVE_ATTRIBS_ARB),
    ENUM_MAPPING(GL_MAX_PROGRAM_NATIVE_INSTRUCTIONS_ARB),
    ENUM_MAPPING(GL_MAX_PROGRAM_NATIVE_PARAMETERS_ARB),
    ENUM_MAPPING(GL_MAX_PROGRAM_NATIVE_TEMPORARIES_ARB),
    ENUM_MAPPING(GL_MAX_PROGRAM_NATIVE_TEX_INDIRECTIONS_ARB),
    ENUM_MAPPING(GL_MAX_PROGRAM_NATIVE_TEX_INSTRUCTIONS_ARB),
    ENUM_MAPPING(GL_MAX_PROGRAM_PARAMETERS_ARB),
    ENUM_MAPPING(GL_MAX_PROGRAM_TEMPORARIES_ARB),
    ENUM_MAPPING(GL_MAX_PROGRAM_TEX_INDIRECTIONS_ARB),
    ENUM_MAPPING(GL_MAX_PROGRAM_TEX_INSTRUCTIONS_ARB),
    ENUM_MAPPING(GL_MAX_PROJECTION_STACK_DEPTH),
    ENUM_MAPPING(GL_MAX_RECTANGLE_TEXTURE_SIZE_ARB),
    ENUM_MAPPING(GL_MAX_RENDERBUFFER_SIZE_EXT),
    ENUM_MAPPING(GL_MAX_SAMPLES_EXT),
    ENUM_MAPPING(GL_MAX_TEXTURE_BUFFER_SIZE_EXT),
    ENUM_MAPPING(GL_MAX_TEXTURE_COORDS),
    ENUM_MAPPING(GL_MAX_TEXTURE_IMAGE_UNITS),
    ENUM_MAPPING(GL_MAX_TEXTURE_LOD_BIAS),
    ENUM_MAPPING(GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT),
    ENUM_MAPPING(GL_MAX_TEXTURE_SIZE),
    ENUM_MAPPING(GL_MAX_TEXTURE_STACK_DEPTH),
    ENUM_MAPPING(GL_MAX_TEXTURE_UNITS),
    ENUM_MAPPING(GL_MAX_VARYING_COMPONENTS_EXT),
    ENUM_MAPPING(GL_MAX_VARYING_FLOATS),
    ENUM_MAPPING(GL_MAX_VERTEX_ATTRIBS),
    ENUM_MAPPING(GL_MAX_VERTEX_BINDABLE_UNIFORMS_EXT),
    ENUM_MAPPING(GL_MAX_VERTEX_HINT_PGI),
    ENUM_MAPPING(GL_MAX_VERTEX_SHADER_INSTRUCTIONS_EXT),
    ENUM_MAPPING(GL_MAX_VERTEX_SHADER_INVARIANTS_EXT),
    ENUM_MAPPING(GL_MAX_VERTEX_SHADER_LOCAL_CONSTANTS_EXT),
    ENUM_MAPPING(GL_MAX_VERTEX_SHADER_LOCALS_EXT),
    ENUM_MAPPING(GL_MAX_VERTEX_SHADER_VARIANTS_EXT),
    ENUM_MAPPING(GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS_ARB),
    ENUM_MAPPING(GL_MAX_VERTEX_UNIFORM_COMPONENTS_ARB),
    ENUM_MAPPING(GL_MAX_VERTEX_UNITS_ARB),
    ENUM_MAPPING(GL_MAX_VERTEX_VARYING_COMPONENTS_EXT),
    ENUM_MAPPING(GL_MAX_VIEWPORT_DIMS),
    ENUM_MAPPING(GL_MIN_EXT),
    ENUM_MAPPING(GL_MINMAX_FORMAT),
    ENUM_MAPPING(GL_MINMAX_SINK),
    ENUM_MAPPING(GL_MIRROR_CLAMP_EXT),
    ENUM_MAPPING(GL_MIRROR_CLAMP_TO_BORDER_EXT),
    ENUM_MAPPING(GL_MIRROR_CLAMP_TO_EDGE_EXT),
    ENUM_MAPPING(GL_MIRRORED_REPEAT),
    ENUM_MAPPING(GL_MODELVIEW),
    ENUM_MAPPING(GL_MODELVIEW_MATRIX),
    ENUM_MAPPING(GL_MODELVIEW_STACK_DEPTH),
    //  ENUM_MAPPING( GL_MODELVIEW0_ARB ),
    //  ENUM_MAPPING( GL_MODELVIEW0_EXT ),
    ENUM_MAPPING(GL_MODELVIEW0_MATRIX_EXT),
    ENUM_MAPPING(GL_MODELVIEW0_STACK_DEPTH_EXT),
    ENUM_MAPPING(GL_MODELVIEW1_ARB),
    ENUM_MAPPING(GL_MODELVIEW1_EXT),
    ENUM_MAPPING(GL_MODELVIEW1_MATRIX_EXT),
    ENUM_MAPPING(GL_MODELVIEW1_STACK_DEPTH_EXT),
    ENUM_MAPPING(GL_MODELVIEW10_ARB),
    ENUM_MAPPING(GL_MODELVIEW11_ARB),
    ENUM_MAPPING(GL_MODELVIEW12_ARB),
    ENUM_MAPPING(GL_MODELVIEW13_ARB),
    ENUM_MAPPING(GL_MODELVIEW14_ARB),
    ENUM_MAPPING(GL_MODELVIEW15_ARB),
    ENUM_MAPPING(GL_MODELVIEW16_ARB),
    ENUM_MAPPING(GL_MODELVIEW17_ARB),
    ENUM_MAPPING(GL_MODELVIEW18_ARB),
    ENUM_MAPPING(GL_MODELVIEW19_ARB),
    ENUM_MAPPING(GL_MODELVIEW2_ARB),
    ENUM_MAPPING(GL_MODELVIEW20_ARB),
    ENUM_MAPPING(GL_MODELVIEW21_ARB),
    ENUM_MAPPING(GL_MODELVIEW22_ARB),
    ENUM_MAPPING(GL_MODELVIEW23_ARB),
    ENUM_MAPPING(GL_MODELVIEW24_ARB),
    ENUM_MAPPING(GL_MODELVIEW25_ARB),
    ENUM_MAPPING(GL_MODELVIEW26_ARB),
    ENUM_MAPPING(GL_MODELVIEW27_ARB),
    ENUM_MAPPING(GL_MODELVIEW28_ARB),
    ENUM_MAPPING(GL_MODELVIEW29_ARB),
    ENUM_MAPPING(GL_MODELVIEW3_ARB),
    ENUM_MAPPING(GL_MODELVIEW30_ARB),
    ENUM_MAPPING(GL_MODELVIEW31_ARB),
    ENUM_MAPPING(GL_MODELVIEW4_ARB),
    ENUM_MAPPING(GL_MODELVIEW5_ARB),
    ENUM_MAPPING(GL_MODELVIEW6_ARB),
    ENUM_MAPPING(GL_MODELVIEW7_ARB),
    ENUM_MAPPING(GL_MODELVIEW8_ARB),
    ENUM_MAPPING(GL_MODELVIEW9_ARB),
    ENUM_MAPPING(GL_MODULATE),
    ENUM_MAPPING(GL_MULT),
    ENUM_MAPPING(GL_MULTISAMPLE_BIT),
    ENUM_MAPPING(GL_MULTISAMPLE_EXT),
    ENUM_MAPPING(GL_MULTISAMPLE_SGIS),
    ENUM_MAPPING(GL_MVP_MATRIX_EXT),
    ENUM_MAPPING(GL_N3F_V3F),
    ENUM_MAPPING(GL_NAME_STACK_DEPTH),
    ENUM_MAPPING(GL_NAND),
    ENUM_MAPPING(GL_NATIVE_GRAPHICS_BEGIN_HINT_PGI),
    ENUM_MAPPING(GL_NATIVE_GRAPHICS_END_HINT_PGI),
    ENUM_MAPPING(GL_NATIVE_GRAPHICS_HANDLE_PGI),
    ENUM_MAPPING(GL_NEAREST),
    ENUM_MAPPING(GL_NEAREST_CLIPMAP_LINEAR_SGIX),
    ENUM_MAPPING(GL_NEAREST_CLIPMAP_NEAREST_SGIX),
    ENUM_MAPPING(GL_NEAREST_MIPMAP_LINEAR),
    ENUM_MAPPING(GL_NEAREST_MIPMAP_NEAREST),
    ENUM_MAPPING(GL_NEGATIVE_ONE_EXT),
    ENUM_MAPPING(GL_NEGATIVE_W_EXT),
    ENUM_MAPPING(GL_NEGATIVE_X_EXT),
    ENUM_MAPPING(GL_NEGATIVE_Y_EXT),
    ENUM_MAPPING(GL_NEGATIVE_Z_EXT),
    ENUM_MAPPING(GL_NEVER),
    ENUM_MAPPING(GL_NICEST),
    ENUM_MAPPING(GL_NO_ERROR),
    ENUM_MAPPING(GL_NONE),
    ENUM_MAPPING(GL_NOOP),
    ENUM_MAPPING(GL_NOR),
    ENUM_MAPPING(GL_NORMAL_ARRAY),
    ENUM_MAPPING(GL_NORMAL_ARRAY_BUFFER_BINDING),
    ENUM_MAPPING(GL_NORMAL_ARRAY_COUNT_EXT),
    ENUM_MAPPING(GL_NORMAL_ARRAY_LIST_IBM),
    ENUM_MAPPING(GL_NORMAL_ARRAY_LIST_STRIDE_IBM),
    ENUM_MAPPING(GL_NORMAL_ARRAY_PARALLEL_POINTERS_INTEL),
    ENUM_MAPPING(GL_NORMAL_ARRAY_POINTER),
    ENUM_MAPPING(GL_NORMAL_ARRAY_POINTER_EXT),
    ENUM_MAPPING(GL_NORMAL_ARRAY_STRIDE),
    ENUM_MAPPING(GL_NORMAL_ARRAY_STRIDE_EXT),
    ENUM_MAPPING(GL_NORMAL_ARRAY_TYPE),
    ENUM_MAPPING(GL_NORMAL_ARRAY_TYPE_EXT),
    ENUM_MAPPING(GL_NORMAL_BIT_PGI),
    ENUM_MAPPING(GL_NORMAL_MAP),
    ENUM_MAPPING(GL_NORMALIZE),
    ENUM_MAPPING(GL_NORMALIZED_RANGE_EXT),
    ENUM_MAPPING(GL_NOTEQUAL),
    ENUM_MAPPING(GL_NUM_COMPRESSED_TEXTURE_FORMATS),
    ENUM_MAPPING(GL_OBJECT_ACTIVE_ATTRIBUTE_MAX_LENGTH_ARB),
    ENUM_MAPPING(GL_OBJECT_ACTIVE_ATTRIBUTES_ARB),
    ENUM_MAPPING(GL_OBJECT_ACTIVE_UNIFORM_MAX_LENGTH_ARB),
    ENUM_MAPPING(GL_OBJECT_ACTIVE_UNIFORMS_ARB),
    ENUM_MAPPING(GL_OBJECT_ATTACHED_OBJECTS_ARB),
    ENUM_MAPPING(GL_OBJECT_COMPILE_STATUS_ARB),
    ENUM_MAPPING(GL_OBJECT_DELETE_STATUS_ARB),
    ENUM_MAPPING(GL_OBJECT_DISTANCE_TO_LINE_SGIS),
    ENUM_MAPPING(GL_OBJECT_DISTANCE_TO_POINT_SGIS),
    ENUM_MAPPING(GL_OBJECT_INFO_LOG_LENGTH_ARB),
    ENUM_MAPPING(GL_OBJECT_LINE_SGIS),
    ENUM_MAPPING(GL_OBJECT_LINEAR),
    ENUM_MAPPING(GL_OBJECT_LINK_STATUS_ARB),
    ENUM_MAPPING(GL_OBJECT_PLANE),
    ENUM_MAPPING(GL_OBJECT_POINT_SGIS),
    ENUM_MAPPING(GL_OBJECT_SHADER_SOURCE_LENGTH_ARB),
    ENUM_MAPPING(GL_OBJECT_SUBTYPE_ARB),
    ENUM_MAPPING(GL_OBJECT_TYPE_ARB),
    ENUM_MAPPING(GL_OBJECT_VALIDATE_STATUS_ARB),
    ENUM_MAPPING(GL_OCCLUSION_TEST_HP),
    ENUM_MAPPING(GL_OCCLUSION_TEST_RESULT_HP),
    ENUM_MAPPING(GL_ONE),
    ENUM_MAPPING(GL_ONE_EXT),
    ENUM_MAPPING(GL_ONE_MINUS_CONSTANT_ALPHA),
    ENUM_MAPPING(GL_ONE_MINUS_CONSTANT_COLOR),
    ENUM_MAPPING(GL_ONE_MINUS_DST_ALPHA),
    ENUM_MAPPING(GL_ONE_MINUS_DST_COLOR),
    ENUM_MAPPING(GL_ONE_MINUS_SRC_ALPHA),
    ENUM_MAPPING(GL_ONE_MINUS_SRC_COLOR),
    ENUM_MAPPING(GL_OP_ADD_EXT),
    ENUM_MAPPING(GL_OP_CLAMP_EXT),
    ENUM_MAPPING(GL_OP_CROSS_PRODUCT_EXT),
    ENUM_MAPPING(GL_OP_DOT3_EXT),
    ENUM_MAPPING(GL_OP_DOT4_EXT),
    ENUM_MAPPING(GL_OP_EXP_BASE_2_EXT),
    ENUM_MAPPING(GL_OP_FLOOR_EXT),
    ENUM_MAPPING(GL_OP_FRAC_EXT),
    ENUM_MAPPING(GL_OP_INDEX_EXT),
    ENUM_MAPPING(GL_OP_LOG_BASE_2_EXT),
    ENUM_MAPPING(GL_OP_MADD_EXT),
    ENUM_MAPPING(GL_OP_MAX_EXT),
    ENUM_MAPPING(GL_OP_MIN_EXT),
    ENUM_MAPPING(GL_OP_MOV_EXT),
    ENUM_MAPPING(GL_OP_MUL_EXT),
    ENUM_MAPPING(GL_OP_MULTIPLY_MATRIX_EXT),
    ENUM_MAPPING(GL_OP_NEGATE_EXT),
    ENUM_MAPPING(GL_OP_POWER_EXT),
    ENUM_MAPPING(GL_OP_RECIP_EXT),
    ENUM_MAPPING(GL_OP_RECIP_SQRT_EXT),
    ENUM_MAPPING(GL_OP_ROUND_EXT),
    ENUM_MAPPING(GL_OP_SET_GE_EXT),
    ENUM_MAPPING(GL_OP_SET_LT_EXT),
    ENUM_MAPPING(GL_OP_SUB_EXT),
    ENUM_MAPPING(GL_OPERAND0_ALPHA),
    ENUM_MAPPING(GL_OPERAND0_RGB),
    ENUM_MAPPING(GL_OPERAND1_ALPHA),
    ENUM_MAPPING(GL_OPERAND1_RGB),
    ENUM_MAPPING(GL_OPERAND2_ALPHA),
    ENUM_MAPPING(GL_OPERAND2_RGB),
    ENUM_MAPPING(GL_OR),
    ENUM_MAPPING(GL_OR_INVERTED),
    ENUM_MAPPING(GL_OR_REVERSE),
    ENUM_MAPPING(GL_ORDER),
    ENUM_MAPPING(GL_OUT_OF_MEMORY),
    ENUM_MAPPING(GL_OUTPUT_COLOR0_EXT),
    ENUM_MAPPING(GL_OUTPUT_COLOR1_EXT),
    ENUM_MAPPING(GL_OUTPUT_FOG_EXT),
    ENUM_MAPPING(GL_OUTPUT_TEXTURE_COORD0_EXT),
    ENUM_MAPPING(GL_OUTPUT_TEXTURE_COORD1_EXT),
    ENUM_MAPPING(GL_OUTPUT_TEXTURE_COORD10_EXT),
    ENUM_MAPPING(GL_OUTPUT_TEXTURE_COORD11_EXT),
    ENUM_MAPPING(GL_OUTPUT_TEXTURE_COORD12_EXT),
    ENUM_MAPPING(GL_OUTPUT_TEXTURE_COORD13_EXT),
    ENUM_MAPPING(GL_OUTPUT_TEXTURE_COORD14_EXT),
    ENUM_MAPPING(GL_OUTPUT_TEXTURE_COORD15_EXT),
    ENUM_MAPPING(GL_OUTPUT_TEXTURE_COORD16_EXT),
    ENUM_MAPPING(GL_OUTPUT_TEXTURE_COORD17_EXT),
    ENUM_MAPPING(GL_OUTPUT_TEXTURE_COORD18_EXT),
    ENUM_MAPPING(GL_OUTPUT_TEXTURE_COORD19_EXT),
    ENUM_MAPPING(GL_OUTPUT_TEXTURE_COORD2_EXT),
    ENUM_MAPPING(GL_OUTPUT_TEXTURE_COORD20_EXT),
    ENUM_MAPPING(GL_OUTPUT_TEXTURE_COORD21_EXT),
    ENUM_MAPPING(GL_OUTPUT_TEXTURE_COORD22_EXT),
    ENUM_MAPPING(GL_OUTPUT_TEXTURE_COORD23_EXT),
    ENUM_MAPPING(GL_OUTPUT_TEXTURE_COORD24_EXT),
    ENUM_MAPPING(GL_OUTPUT_TEXTURE_COORD25_EXT),
    ENUM_MAPPING(GL_OUTPUT_TEXTURE_COORD26_EXT),
    ENUM_MAPPING(GL_OUTPUT_TEXTURE_COORD27_EXT),
    ENUM_MAPPING(GL_OUTPUT_TEXTURE_COORD28_EXT),
    ENUM_MAPPING(GL_OUTPUT_TEXTURE_COORD29_EXT),
    ENUM_MAPPING(GL_OUTPUT_TEXTURE_COORD3_EXT),
    ENUM_MAPPING(GL_OUTPUT_TEXTURE_COORD30_EXT),
    ENUM_MAPPING(GL_OUTPUT_TEXTURE_COORD31_EXT),
    ENUM_MAPPING(GL_OUTPUT_TEXTURE_COORD4_EXT),
    ENUM_MAPPING(GL_OUTPUT_TEXTURE_COORD5_EXT),
    ENUM_MAPPING(GL_OUTPUT_TEXTURE_COORD6_EXT),
    ENUM_MAPPING(GL_OUTPUT_TEXTURE_COORD7_EXT),
    ENUM_MAPPING(GL_OUTPUT_TEXTURE_COORD8_EXT),
    ENUM_MAPPING(GL_OUTPUT_TEXTURE_COORD9_EXT),
    ENUM_MAPPING(GL_OUTPUT_VERTEX_EXT),
    ENUM_MAPPING(GL_PACK_ALIGNMENT),
    ENUM_MAPPING(GL_PACK_CMYK_HINT_EXT),
    ENUM_MAPPING(GL_PACK_IMAGE_DEPTH_SGIS),
    ENUM_MAPPING(GL_PACK_IMAGE_HEIGHT),
    ENUM_MAPPING(GL_PACK_INVERT_MESA),
    ENUM_MAPPING(GL_PACK_LSB_FIRST),
    ENUM_MAPPING(GL_PACK_RESAMPLE_OML),
    ENUM_MAPPING(GL_PACK_RESAMPLE_SGIX),
    ENUM_MAPPING(GL_PACK_ROW_LENGTH),
    ENUM_MAPPING(GL_PACK_SKIP_IMAGES),
    ENUM_MAPPING(GL_PACK_SKIP_PIXELS),
    ENUM_MAPPING(GL_PACK_SKIP_ROWS),
    ENUM_MAPPING(GL_PACK_SKIP_VOLUMES_SGIS),
    ENUM_MAPPING(GL_PACK_SUBSAMPLE_RATE_SGIX),
    ENUM_MAPPING(GL_PACK_SWAP_BYTES),
    ENUM_MAPPING(GL_PARALLEL_ARRAYS_INTEL),
    ENUM_MAPPING(GL_PASS_THROUGH_TOKEN),
    ENUM_MAPPING(GL_PERSPECTIVE_CORRECTION_HINT),
    ENUM_MAPPING(GL_PERTURB_EXT),
    ENUM_MAPPING(GL_PHONG_HINT_WIN),
    ENUM_MAPPING(GL_PHONG_WIN),
    ENUM_MAPPING(GL_PIXEL_CUBIC_WEIGHT_EXT),
    ENUM_MAPPING(GL_PIXEL_FRAGMENT_ALPHA_SOURCE_SGIS),
    ENUM_MAPPING(GL_PIXEL_FRAGMENT_RGB_SOURCE_SGIS),
    ENUM_MAPPING(GL_PIXEL_GROUP_COLOR_SGIS),
    ENUM_MAPPING(GL_PIXEL_MAG_FILTER_EXT),
    ENUM_MAPPING(GL_PIXEL_MAP_A_TO_A),
    ENUM_MAPPING(GL_PIXEL_MAP_A_TO_A_SIZE),
    ENUM_MAPPING(GL_PIXEL_MAP_B_TO_B),
    ENUM_MAPPING(GL_PIXEL_MAP_B_TO_B_SIZE),
    ENUM_MAPPING(GL_PIXEL_MAP_G_TO_G),
    ENUM_MAPPING(GL_PIXEL_MAP_G_TO_G_SIZE),
    ENUM_MAPPING(GL_PIXEL_MAP_I_TO_A),
    ENUM_MAPPING(GL_PIXEL_MAP_I_TO_A_SIZE),
    ENUM_MAPPING(GL_PIXEL_MAP_I_TO_B),
    ENUM_MAPPING(GL_PIXEL_MAP_I_TO_B_SIZE),
    ENUM_MAPPING(GL_PIXEL_MAP_I_TO_G),
    ENUM_MAPPING(GL_PIXEL_MAP_I_TO_G_SIZE),
    ENUM_MAPPING(GL_PIXEL_MAP_I_TO_I),
    ENUM_MAPPING(GL_PIXEL_MAP_I_TO_I_SIZE),
    ENUM_MAPPING(GL_PIXEL_MAP_I_TO_R),
    ENUM_MAPPING(GL_PIXEL_MAP_I_TO_R_SIZE),
    ENUM_MAPPING(GL_PIXEL_MAP_R_TO_R),
    ENUM_MAPPING(GL_PIXEL_MAP_R_TO_R_SIZE),
    ENUM_MAPPING(GL_PIXEL_MAP_S_TO_S),
    ENUM_MAPPING(GL_PIXEL_MAP_S_TO_S_SIZE),
    ENUM_MAPPING(GL_PIXEL_MIN_FILTER_EXT),
    ENUM_MAPPING(GL_PIXEL_MODE_BIT),
    ENUM_MAPPING(GL_PIXEL_PACK_BUFFER_BINDING),
    ENUM_MAPPING(GL_PIXEL_SUBSAMPLE_2424_SGIX),
    ENUM_MAPPING(GL_PIXEL_SUBSAMPLE_4242_SGIX),
    ENUM_MAPPING(GL_PIXEL_SUBSAMPLE_4444_SGIX),
    ENUM_MAPPING(GL_PIXEL_TEX_GEN_ALPHA_LS_SGIX),
    ENUM_MAPPING(GL_PIXEL_TEX_GEN_ALPHA_MS_SGIX),
    ENUM_MAPPING(GL_PIXEL_TEX_GEN_ALPHA_NO_REPLACE_SGIX),
    ENUM_MAPPING(GL_PIXEL_TEX_GEN_ALPHA_REPLACE_SGIX),
    ENUM_MAPPING(GL_PIXEL_TEX_GEN_MODE_SGIX),
    ENUM_MAPPING(GL_PIXEL_TEX_GEN_Q_CEILING_SGIX),
    ENUM_MAPPING(GL_PIXEL_TEX_GEN_Q_FLOOR_SGIX),
    ENUM_MAPPING(GL_PIXEL_TEX_GEN_Q_ROUND_SGIX),
    ENUM_MAPPING(GL_PIXEL_TEX_GEN_SGIX),
    ENUM_MAPPING(GL_PIXEL_TEXTURE_SGIS),
    ENUM_MAPPING(GL_PIXEL_TILE_BEST_ALIGNMENT_SGIX),
    ENUM_MAPPING(GL_PIXEL_TILE_CACHE_INCREMENT_SGIX),
    ENUM_MAPPING(GL_PIXEL_TILE_CACHE_SIZE_SGIX),
    ENUM_MAPPING(GL_PIXEL_TILE_GRID_DEPTH_SGIX),
    ENUM_MAPPING(GL_PIXEL_TILE_GRID_HEIGHT_SGIX),
    ENUM_MAPPING(GL_PIXEL_TILE_GRID_WIDTH_SGIX),
    ENUM_MAPPING(GL_PIXEL_TILE_HEIGHT_SGIX),
    ENUM_MAPPING(GL_PIXEL_TILE_WIDTH_SGIX),
    ENUM_MAPPING(GL_PIXEL_TRANSFORM_2D_EXT),
    ENUM_MAPPING(GL_PIXEL_TRANSFORM_2D_MATRIX_EXT),
    ENUM_MAPPING(GL_PIXEL_TRANSFORM_2D_STACK_DEPTH_EXT),
    ENUM_MAPPING(GL_PIXEL_UNPACK_BUFFER_BINDING),
    ENUM_MAPPING(GL_POINT),
    ENUM_MAPPING(GL_POINT_BIT),
    ENUM_MAPPING(GL_POINT_DISTANCE_ATTENUATION),
    ENUM_MAPPING(GL_POINT_FADE_THRESHOLD_SIZE),
    ENUM_MAPPING(GL_POINT_SIZE),
    ENUM_MAPPING(GL_POINT_SIZE_GRANULARITY),
    ENUM_MAPPING(GL_POINT_SIZE_MAX),
    ENUM_MAPPING(GL_POINT_SIZE_MIN),
    ENUM_MAPPING(GL_POINT_SIZE_RANGE),
    ENUM_MAPPING(GL_POINT_SMOOTH),
    ENUM_MAPPING(GL_POINT_SMOOTH_HINT),
    ENUM_MAPPING(GL_POINT_SPRITE),
    ENUM_MAPPING(GL_POINT_SPRITE_COORD_ORIGIN),
    ENUM_MAPPING(GL_POINT_TOKEN),
    ENUM_MAPPING(GL_POINTS),
    ENUM_MAPPING(GL_POLYGON),
    ENUM_MAPPING(GL_POLYGON_BIT),
    ENUM_MAPPING(GL_POLYGON_MODE),
    ENUM_MAPPING(GL_POLYGON_OFFSET_BIAS_EXT),
    ENUM_MAPPING(GL_POLYGON_OFFSET_EXT),
    ENUM_MAPPING(GL_POLYGON_OFFSET_FACTOR),
    ENUM_MAPPING(GL_POLYGON_OFFSET_FACTOR_EXT),
    ENUM_MAPPING(GL_POLYGON_OFFSET_FILL),
    ENUM_MAPPING(GL_POLYGON_OFFSET_LINE),
    ENUM_MAPPING(GL_POLYGON_OFFSET_POINT),
    ENUM_MAPPING(GL_POLYGON_OFFSET_UNITS),
    ENUM_MAPPING(GL_POLYGON_SMOOTH),
    ENUM_MAPPING(GL_POLYGON_SMOOTH_HINT),
    ENUM_MAPPING(GL_POLYGON_STIPPLE),
    ENUM_MAPPING(GL_POLYGON_STIPPLE_BIT),
    ENUM_MAPPING(GL_POLYGON_TOKEN),
    ENUM_MAPPING(GL_POSITION),
    ENUM_MAPPING(GL_POST_COLOR_MATRIX_ALPHA_BIAS),
    ENUM_MAPPING(GL_POST_COLOR_MATRIX_ALPHA_SCALE),
    ENUM_MAPPING(GL_POST_COLOR_MATRIX_BLUE_BIAS),
    ENUM_MAPPING(GL_POST_COLOR_MATRIX_BLUE_SCALE),
    ENUM_MAPPING(GL_POST_COLOR_MATRIX_COLOR_TABLE),
    ENUM_MAPPING(GL_POST_COLOR_MATRIX_GREEN_BIAS),
    ENUM_MAPPING(GL_POST_COLOR_MATRIX_GREEN_SCALE),
    ENUM_MAPPING(GL_POST_COLOR_MATRIX_RED_BIAS),
    ENUM_MAPPING(GL_POST_COLOR_MATRIX_RED_SCALE),
    ENUM_MAPPING(GL_POST_CONVOLUTION_ALPHA_BIAS),
    ENUM_MAPPING(GL_POST_CONVOLUTION_ALPHA_SCALE),
    ENUM_MAPPING(GL_POST_CONVOLUTION_BLUE_BIAS),
    ENUM_MAPPING(GL_POST_CONVOLUTION_BLUE_SCALE),
    ENUM_MAPPING(GL_POST_CONVOLUTION_COLOR_TABLE),
    ENUM_MAPPING(GL_POST_CONVOLUTION_GREEN_BIAS),
    ENUM_MAPPING(GL_POST_CONVOLUTION_GREEN_SCALE),
    ENUM_MAPPING(GL_POST_CONVOLUTION_RED_BIAS),
    ENUM_MAPPING(GL_POST_CONVOLUTION_RED_SCALE),
    ENUM_MAPPING(GL_POST_IMAGE_TRANSFORM_COLOR_TABLE_HP),
    ENUM_MAPPING(GL_POST_TEXTURE_FILTER_BIAS_RANGE_SGIX),
    ENUM_MAPPING(GL_POST_TEXTURE_FILTER_BIAS_SGIX),
    ENUM_MAPPING(GL_POST_TEXTURE_FILTER_SCALE_RANGE_SGIX),
    ENUM_MAPPING(GL_POST_TEXTURE_FILTER_SCALE_SGIX),
    ENUM_MAPPING(GL_PREFER_DOUBLEBUFFER_HINT_PGI),
    ENUM_MAPPING(GL_PRIMARY_COLOR),
    ENUM_MAPPING(GL_PROGRAM_ADDRESS_REGISTERS_ARB),
    ENUM_MAPPING(GL_PROGRAM_ALU_INSTRUCTIONS_ARB),
    ENUM_MAPPING(GL_PROGRAM_ATTRIBS_ARB),
    ENUM_MAPPING(GL_PROGRAM_BINDING_ARB),
    ENUM_MAPPING(GL_PROGRAM_ERROR_POSITION_ARB),
    ENUM_MAPPING(GL_PROGRAM_ERROR_STRING_ARB),
    ENUM_MAPPING(GL_PROGRAM_FORMAT_ARB),
    ENUM_MAPPING(GL_PROGRAM_FORMAT_ASCII_ARB),
    ENUM_MAPPING(GL_PROGRAM_INSTRUCTIONS_ARB),
    ENUM_MAPPING(GL_PROGRAM_LENGTH_ARB),
    ENUM_MAPPING(GL_PROGRAM_NATIVE_ADDRESS_REGISTERS_ARB),
    ENUM_MAPPING(GL_PROGRAM_NATIVE_ALU_INSTRUCTIONS_ARB),
    ENUM_MAPPING(GL_PROGRAM_NATIVE_ATTRIBS_ARB),
    ENUM_MAPPING(GL_PROGRAM_NATIVE_INSTRUCTIONS_ARB),
    ENUM_MAPPING(GL_PROGRAM_NATIVE_PARAMETERS_ARB),
    ENUM_MAPPING(GL_PROGRAM_NATIVE_TEMPORARIES_ARB),
    ENUM_MAPPING(GL_PROGRAM_NATIVE_TEX_INDIRECTIONS_ARB),
    ENUM_MAPPING(GL_PROGRAM_NATIVE_TEX_INSTRUCTIONS_ARB),
    ENUM_MAPPING(GL_PROGRAM_OBJECT_ARB),
    ENUM_MAPPING(GL_PROGRAM_PARAMETERS_ARB),
    ENUM_MAPPING(GL_PROGRAM_POINT_SIZE_EXT),
    ENUM_MAPPING(GL_PROGRAM_STRING_ARB),
    ENUM_MAPPING(GL_PROGRAM_TEMPORARIES_ARB),
    ENUM_MAPPING(GL_PROGRAM_TEX_INDIRECTIONS_ARB),
    ENUM_MAPPING(GL_PROGRAM_TEX_INSTRUCTIONS_ARB),
    ENUM_MAPPING(GL_PROGRAM_UNDER_NATIVE_LIMITS_ARB),
    ENUM_MAPPING(GL_PROJECTION),
    ENUM_MAPPING(GL_PROJECTION_MATRIX),
    ENUM_MAPPING(GL_PROJECTION_STACK_DEPTH),
    ENUM_MAPPING(GL_PROXY_COLOR_TABLE),
    ENUM_MAPPING(GL_PROXY_HISTOGRAM),
    ENUM_MAPPING(GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE),
    ENUM_MAPPING(GL_PROXY_POST_CONVOLUTION_COLOR_TABLE),
    ENUM_MAPPING(GL_PROXY_POST_IMAGE_TRANSFORM_COLOR_TABLE_HP),
    ENUM_MAPPING(GL_PROXY_TEXTURE_1D),
    ENUM_MAPPING(GL_PROXY_TEXTURE_1D_ARRAY_EXT),
    ENUM_MAPPING(GL_PROXY_TEXTURE_1D_STACK_MESAX),
    ENUM_MAPPING(GL_PROXY_TEXTURE_2D),
    ENUM_MAPPING(GL_PROXY_TEXTURE_2D_ARRAY_EXT),
    ENUM_MAPPING(GL_PROXY_TEXTURE_2D_STACK_MESAX),
    ENUM_MAPPING(GL_PROXY_TEXTURE_3D),
    ENUM_MAPPING(GL_PROXY_TEXTURE_4D_SGIS),
    ENUM_MAPPING(GL_PROXY_TEXTURE_COLOR_TABLE_SGI),
    ENUM_MAPPING(GL_PROXY_TEXTURE_CUBE_MAP),
    ENUM_MAPPING(GL_PROXY_TEXTURE_RECTANGLE_ARB),
    ENUM_MAPPING(GL_Q),
    ENUM_MAPPING(GL_QUAD_ALPHA4_SGIS),
    ENUM_MAPPING(GL_QUAD_ALPHA8_SGIS),
    ENUM_MAPPING(GL_QUAD_INTENSITY4_SGIS),
    ENUM_MAPPING(GL_QUAD_INTENSITY8_SGIS),
    ENUM_MAPPING(GL_QUAD_LUMINANCE4_SGIS),
    ENUM_MAPPING(GL_QUAD_LUMINANCE8_SGIS),
    ENUM_MAPPING(GL_QUAD_MESH_SUN),
    ENUM_MAPPING(GL_QUAD_STRIP),
    ENUM_MAPPING(GL_QUAD_TEXTURE_SELECT_SGIS),
    ENUM_MAPPING(GL_QUADRATIC_ATTENUATION),
    ENUM_MAPPING(GL_QUADS),
    ENUM_MAPPING(GL_QUERY_COUNTER_BITS),
    ENUM_MAPPING(GL_QUERY_RESULT_AVAILABLE),
    ENUM_MAPPING(GL_R),
    ENUM_MAPPING(GL_R11F_G11F_B10F_EXT),
    ENUM_MAPPING(GL_R1UI_C3F_V3F_SUN),
    ENUM_MAPPING(GL_R1UI_C4F_N3F_V3F_SUN),
    ENUM_MAPPING(GL_R1UI_C4UB_V3F_SUN),
    ENUM_MAPPING(GL_R1UI_N3F_V3F_SUN),
    ENUM_MAPPING(GL_R1UI_T2F_C4F_N3F_V3F_SUN),
    ENUM_MAPPING(GL_R1UI_T2F_N3F_V3F_SUN),
    ENUM_MAPPING(GL_R1UI_T2F_V3F_SUN),
    ENUM_MAPPING(GL_R1UI_V3F_SUN),
    ENUM_MAPPING(GL_R3_G3_B2),
    ENUM_MAPPING(GL_RASTER_POSITION_UNCLIPPED_IBM),
    ENUM_MAPPING(GL_READ_BUFFER),
    ENUM_MAPPING(GL_READ_FRAMEBUFFER_BINDING_EXT),
    ENUM_MAPPING(GL_READ_FRAMEBUFFER_EXT),
    ENUM_MAPPING(GL_READ_ONLY),
    ENUM_MAPPING(GL_READ_WRITE),
    ENUM_MAPPING(GL_RECLAIM_MEMORY_HINT_PGI),
    ENUM_MAPPING(GL_RED),
    ENUM_MAPPING(GL_RED_BIAS),
    ENUM_MAPPING(GL_RED_BITS),
    ENUM_MAPPING(GL_RED_INTEGER_EXT),
    ENUM_MAPPING(GL_RED_MAX_CLAMP_INGR),
    ENUM_MAPPING(GL_RED_MIN_CLAMP_INGR),
    ENUM_MAPPING(GL_RED_SCALE),
    ENUM_MAPPING(GL_REDUCE),
    ENUM_MAPPING(GL_REFERENCE_PLANE_EQUATION_SGIX),
    ENUM_MAPPING(GL_REFERENCE_PLANE_SGIX),
    ENUM_MAPPING(GL_REFLECTION_MAP),
    ENUM_MAPPING(GL_RENDER),
    ENUM_MAPPING(GL_RENDER_MODE),
    ENUM_MAPPING(GL_RENDERBUFFER_ALPHA_SIZE_EXT),
    ENUM_MAPPING(GL_RENDERBUFFER_BINDING_EXT),
    ENUM_MAPPING(GL_RENDERBUFFER_BLUE_SIZE_EXT),
    ENUM_MAPPING(GL_RENDERBUFFER_DEPTH_SIZE_EXT),
    ENUM_MAPPING(GL_RENDERBUFFER_EXT),
    ENUM_MAPPING(GL_RENDERBUFFER_GREEN_SIZE_EXT),
    ENUM_MAPPING(GL_RENDERBUFFER_HEIGHT_EXT),
    ENUM_MAPPING(GL_RENDERBUFFER_INTERNAL_FORMAT_EXT),
    ENUM_MAPPING(GL_RENDERBUFFER_RED_SIZE_EXT),
    ENUM_MAPPING(GL_RENDERBUFFER_SAMPLES_EXT),
    ENUM_MAPPING(GL_RENDERBUFFER_STENCIL_SIZE_EXT),
    ENUM_MAPPING(GL_RENDERBUFFER_WIDTH_EXT),
    ENUM_MAPPING(GL_RENDERER),
    ENUM_MAPPING(GL_REPEAT),
    ENUM_MAPPING(GL_REPLACE),
    ENUM_MAPPING(GL_REPLACE_MIDDLE_SUN),
    ENUM_MAPPING(GL_REPLACE_OLDEST_SUN),
    ENUM_MAPPING(GL_REPLACEMENT_CODE_ARRAY_POINTER_SUN),
    ENUM_MAPPING(GL_REPLACEMENT_CODE_ARRAY_STRIDE_SUN),
    ENUM_MAPPING(GL_REPLACEMENT_CODE_ARRAY_SUN),
    ENUM_MAPPING(GL_REPLACEMENT_CODE_ARRAY_TYPE_SUN),
    ENUM_MAPPING(GL_REPLACEMENT_CODE_SUN),
    ENUM_MAPPING(GL_REPLICATE_BORDER),
    ENUM_MAPPING(GL_RESAMPLE_AVERAGE_OML),
    ENUM_MAPPING(GL_RESAMPLE_DECIMATE_OML),
    ENUM_MAPPING(GL_RESAMPLE_DECIMATE_SGIX),
    ENUM_MAPPING(GL_RESAMPLE_REPLICATE_OML),
    ENUM_MAPPING(GL_RESAMPLE_REPLICATE_SGIX),
    ENUM_MAPPING(GL_RESAMPLE_ZERO_FILL_OML),
    ENUM_MAPPING(GL_RESAMPLE_ZERO_FILL_SGIX),
    ENUM_MAPPING(GL_RESCALE_NORMAL),
    ENUM_MAPPING(GL_RESTART_SUN),
    ENUM_MAPPING(GL_RETURN),
    ENUM_MAPPING(GL_RGB),
    ENUM_MAPPING(GL_RGB_INTEGER_EXT),
    ENUM_MAPPING(GL_RGB_S3TC),
    ENUM_MAPPING(GL_RGB_SCALE),
    ENUM_MAPPING(GL_RGB10),
    ENUM_MAPPING(GL_RGB10_A2),
    ENUM_MAPPING(GL_RGB10_EXT),
    ENUM_MAPPING(GL_RGB12),
    ENUM_MAPPING(GL_RGB16),
    ENUM_MAPPING(GL_RGB16F_ARB),
    ENUM_MAPPING(GL_RGB16I_EXT),
    ENUM_MAPPING(GL_RGB16UI_EXT),
    ENUM_MAPPING(GL_RGB2_EXT),
    ENUM_MAPPING(GL_RGB32F_ARB),
    ENUM_MAPPING(GL_RGB32I_EXT),
    ENUM_MAPPING(GL_RGB32UI_EXT),
    ENUM_MAPPING(GL_RGB4),
    ENUM_MAPPING(GL_RGB4_S3TC),
    ENUM_MAPPING(GL_RGB5),
    ENUM_MAPPING(GL_RGB5_A1),
    ENUM_MAPPING(GL_RGB5_A1_EXT),
    ENUM_MAPPING(GL_RGB5_EXT),
    ENUM_MAPPING(GL_RGB8),
    ENUM_MAPPING(GL_RGB8I_EXT),
    ENUM_MAPPING(GL_RGB8UI_EXT),
    ENUM_MAPPING(GL_RGB9_E5_EXT),
    ENUM_MAPPING(GL_RGBA),
    ENUM_MAPPING(GL_RGBA_FLOAT_MODE_ARB),
    ENUM_MAPPING(GL_RGBA_INTEGER_EXT),
    ENUM_MAPPING(GL_RGBA_INTEGER_MODE_EXT),
    ENUM_MAPPING(GL_RGBA_MODE),
    ENUM_MAPPING(GL_RGBA_S3TC),
    ENUM_MAPPING(GL_RGBA_SIGNED_COMPONENTS_EXT),
    ENUM_MAPPING(GL_RGBA12),
    ENUM_MAPPING(GL_RGBA16),
    ENUM_MAPPING(GL_RGBA16F_ARB),
    ENUM_MAPPING(GL_RGBA16I_EXT),
    ENUM_MAPPING(GL_RGBA16UI_EXT),
    ENUM_MAPPING(GL_RGBA2),
    ENUM_MAPPING(GL_RGBA32F_ARB),
    ENUM_MAPPING(GL_RGBA32I_EXT),
    ENUM_MAPPING(GL_RGBA32UI_EXT),
    ENUM_MAPPING(GL_RGBA4),
    ENUM_MAPPING(GL_RGBA4_S3TC),
    ENUM_MAPPING(GL_RGBA8),
    ENUM_MAPPING(GL_RGBA8I_EXT),
    ENUM_MAPPING(GL_RGBA8UI_EXT),
    ENUM_MAPPING(GL_RIGHT),
    ENUM_MAPPING(GL_S),
    ENUM_MAPPING(GL_SAMPLE_ALPHA_TO_COVERAGE),
    ENUM_MAPPING(GL_SAMPLE_ALPHA_TO_MASK_EXT),
    ENUM_MAPPING(GL_SAMPLE_ALPHA_TO_MASK_SGIS),
    ENUM_MAPPING(GL_SAMPLE_ALPHA_TO_ONE),
    ENUM_MAPPING(GL_SAMPLE_BUFFERS),
    ENUM_MAPPING(GL_SAMPLE_COVERAGE_INVERT),
    ENUM_MAPPING(GL_SAMPLE_COVERAGE_VALUE),
    ENUM_MAPPING(GL_SAMPLE_MASK_EXT),
    ENUM_MAPPING(GL_SAMPLE_MASK_INVERT_EXT),
    ENUM_MAPPING(GL_SAMPLE_MASK_INVERT_SGIS),
    ENUM_MAPPING(GL_SAMPLE_MASK_SGIS),
    ENUM_MAPPING(GL_SAMPLE_MASK_VALUE_EXT),
    ENUM_MAPPING(GL_SAMPLE_MASK_VALUE_SGIS),
    ENUM_MAPPING(GL_SAMPLE_PATTERN_EXT),
    ENUM_MAPPING(GL_SAMPLE_PATTERN_SGIS),
    ENUM_MAPPING(GL_SAMPLER_1D_ARRAY_EXT),
    ENUM_MAPPING(GL_SAMPLER_1D_ARRAY_SHADOW_EXT),
    ENUM_MAPPING(GL_SAMPLER_1D_SHADOW),
    ENUM_MAPPING(GL_SAMPLER_2D_ARRAY_EXT),
    ENUM_MAPPING(GL_SAMPLER_2D_ARRAY_SHADOW_EXT),
    ENUM_MAPPING(GL_SAMPLER_2D_RECT_ARB),
    ENUM_MAPPING(GL_SAMPLER_2D_RECT_SHADOW_ARB),
    ENUM_MAPPING(GL_SAMPLER_2D_SHADOW),
    ENUM_MAPPING(GL_SAMPLER_3D),
    ENUM_MAPPING(GL_SAMPLER_BUFFER_EXT),
    ENUM_MAPPING(GL_SAMPLER_CUBE_SHADOW_EXT),
    ENUM_MAPPING(GL_SAMPLES_PASSED),
    ENUM_MAPPING(GL_SCALEBIAS_HINT_SGIX),
    ENUM_MAPPING(GL_SCISSOR_BIT),
    ENUM_MAPPING(GL_SCISSOR_BOX),
    ENUM_MAPPING(GL_SCISSOR_TEST),
    ENUM_MAPPING(GL_SCREEN_COORDINATES_REND),
    ENUM_MAPPING(GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING),
    ENUM_MAPPING(GL_SECONDARY_COLOR_ARRAY_LIST_IBM),
    ENUM_MAPPING(GL_SECONDARY_COLOR_ARRAY_LIST_STRIDE_IBM),
    ENUM_MAPPING(GL_SECONDARY_COLOR_ARRAY_POINTER),
    ENUM_MAPPING(GL_SECONDARY_COLOR_ARRAY_SIZE),
    ENUM_MAPPING(GL_SECONDARY_COLOR_ARRAY_STRIDE),
    ENUM_MAPPING(GL_SECONDARY_COLOR_ARRAY_TYPE),
    ENUM_MAPPING(GL_SELECT),
    ENUM_MAPPING(GL_SELECTION_BUFFER_POINTER),
    ENUM_MAPPING(GL_SELECTION_BUFFER_SIZE),
    ENUM_MAPPING(GL_SEPARABLE_2D),
    ENUM_MAPPING(GL_SEPARATE_SPECULAR_COLOR),
    ENUM_MAPPING(GL_SET),
    ENUM_MAPPING(GL_SHADE_MODEL),
    ENUM_MAPPING(GL_SHADER_OBJECT_ARB),
    ENUM_MAPPING(GL_SHADER_SOURCE_LENGTH),
    ENUM_MAPPING(GL_SHADER_TYPE),
    ENUM_MAPPING(GL_SHADING_LANGUAGE_VERSION),
    ENUM_MAPPING(GL_SHADOW_AMBIENT_SGIX),
    ENUM_MAPPING(GL_SHADOW_ATTENUATION_EXT),
    ENUM_MAPPING(GL_SHARED_TEXTURE_PALETTE_EXT),
    ENUM_MAPPING(GL_SHARPEN_TEXTURE_FUNC_POINTS_SGIS),
    ENUM_MAPPING(GL_SHININESS),
    ENUM_MAPPING(GL_SHORT),
    ENUM_MAPPING(GL_SINGLE_COLOR),
    ENUM_MAPPING(GL_SLICE_ACCUM_SUN),
    ENUM_MAPPING(GL_SLUMINANCE_ALPHA),
    ENUM_MAPPING(GL_SLUMINANCE8_ALPHA8),
    ENUM_MAPPING(GL_SMOOTH),
    ENUM_MAPPING(GL_SMOOTH_LINE_WIDTH_GRANULARITY),
    ENUM_MAPPING(GL_SMOOTH_LINE_WIDTH_RANGE),
    ENUM_MAPPING(GL_SMOOTH_POINT_SIZE_GRANULARITY),
    ENUM_MAPPING(GL_SMOOTH_POINT_SIZE_RANGE),
    //  ENUM_MAPPING( GL_SOURCE0_ALPHA ),
    //  ENUM_MAPPING( GL_SOURCE0_RGB ),
    //  ENUM_MAPPING( GL_SOURCE1_ALPHA ),
    //  ENUM_MAPPING( GL_SOURCE1_RGB ),
    //  ENUM_MAPPING( GL_SOURCE2_ALPHA ),
    //  ENUM_MAPPING( GL_SOURCE2_RGB ),
    ENUM_MAPPING(GL_SPECULAR),
    ENUM_MAPPING(GL_SPHERE_MAP),
    ENUM_MAPPING(GL_SPOT_CUTOFF),
    ENUM_MAPPING(GL_SPOT_DIRECTION),
    ENUM_MAPPING(GL_SPOT_EXPONENT),
    ENUM_MAPPING(GL_SPRITE_AXIAL_SGIX),
    ENUM_MAPPING(GL_SPRITE_AXIS_SGIX),
    ENUM_MAPPING(GL_SPRITE_EYE_ALIGNED_SGIX),
    ENUM_MAPPING(GL_SPRITE_MODE_SGIX),
    ENUM_MAPPING(GL_SPRITE_OBJECT_ALIGNED_SGIX),
    ENUM_MAPPING(GL_SPRITE_SGIX),
    ENUM_MAPPING(GL_SPRITE_TRANSLATION_SGIX),
    ENUM_MAPPING(GL_SRC_ALPHA),
    ENUM_MAPPING(GL_SRC_ALPHA_SATURATE),
    ENUM_MAPPING(GL_SRC_COLOR),
    ENUM_MAPPING(GL_SRC0_ALPHA),
    ENUM_MAPPING(GL_SRC0_RGB),
    ENUM_MAPPING(GL_SRC1_ALPHA),
    ENUM_MAPPING(GL_SRC1_RGB),
    ENUM_MAPPING(GL_SRC2_ALPHA),
    ENUM_MAPPING(GL_SRC2_RGB),
    ENUM_MAPPING(GL_SRGB_ALPHA),
    ENUM_MAPPING(GL_SRGB8_ALPHA8),
    ENUM_MAPPING(GL_STACK_OVERFLOW),
    ENUM_MAPPING(GL_STACK_UNDERFLOW),
    ENUM_MAPPING(GL_STATIC_COPY),
    ENUM_MAPPING(GL_STATIC_DRAW),
    ENUM_MAPPING(GL_STATIC_READ),
    ENUM_MAPPING(GL_STENCIL),
    ENUM_MAPPING(GL_STENCIL_ATTACHMENT_EXT),
    ENUM_MAPPING(GL_STENCIL_BACK_FAIL),
    ENUM_MAPPING(GL_STENCIL_BACK_FUNC),
    ENUM_MAPPING(GL_STENCIL_BACK_PASS_DEPTH_FAIL),
    ENUM_MAPPING(GL_STENCIL_BACK_PASS_DEPTH_PASS),
    ENUM_MAPPING(GL_STENCIL_BACK_REF),
    ENUM_MAPPING(GL_STENCIL_BACK_VALUE_MASK),
    ENUM_MAPPING(GL_STENCIL_BACK_WRITEMASK),
    ENUM_MAPPING(GL_STENCIL_BITS),
    ENUM_MAPPING(GL_STENCIL_BUFFER_BIT),
    ENUM_MAPPING(GL_STENCIL_CLEAR_TAG_VALUE_EXT),
    ENUM_MAPPING(GL_STENCIL_CLEAR_VALUE),
    ENUM_MAPPING(GL_STENCIL_FAIL),
    ENUM_MAPPING(GL_STENCIL_FUNC),
    ENUM_MAPPING(GL_STENCIL_INDEX),
    ENUM_MAPPING(GL_STENCIL_INDEX1_EXT),
    ENUM_MAPPING(GL_STENCIL_INDEX16_EXT),
    ENUM_MAPPING(GL_STENCIL_INDEX4_EXT),
    ENUM_MAPPING(GL_STENCIL_INDEX8_EXT),
    ENUM_MAPPING(GL_STENCIL_PASS_DEPTH_FAIL),
    ENUM_MAPPING(GL_STENCIL_PASS_DEPTH_PASS),
    ENUM_MAPPING(GL_STENCIL_REF),
    ENUM_MAPPING(GL_STENCIL_TAG_BITS_EXT),
    ENUM_MAPPING(GL_STENCIL_TEST),
    ENUM_MAPPING(GL_STENCIL_TEST_TWO_SIDE_EXT),
    ENUM_MAPPING(GL_STENCIL_VALUE_MASK),
    ENUM_MAPPING(GL_STENCIL_WRITEMASK),
    ENUM_MAPPING(GL_STEREO),
    ENUM_MAPPING(GL_STORAGE_CACHED_APPLE),
    ENUM_MAPPING(GL_STORAGE_SHARED_APPLE),
    ENUM_MAPPING(GL_STREAM_COPY),
    ENUM_MAPPING(GL_STREAM_DRAW),
    ENUM_MAPPING(GL_STREAM_READ),
    ENUM_MAPPING(GL_STRICT_DEPTHFUNC_HINT_PGI),
    ENUM_MAPPING(GL_STRICT_LIGHTING_HINT_PGI),
    ENUM_MAPPING(GL_STRICT_SCISSOR_HINT_PGI),
    ENUM_MAPPING(GL_SUBPIXEL_BITS),
    ENUM_MAPPING(GL_SUBTRACT),
    ENUM_MAPPING(GL_T),
    ENUM_MAPPING(GL_T2F_C3F_V3F),
    ENUM_MAPPING(GL_T2F_C4F_N3F_V3F),
    ENUM_MAPPING(GL_T2F_C4UB_V3F),
    ENUM_MAPPING(GL_T2F_IUI_N3F_V2F_EXT),
    ENUM_MAPPING(GL_T2F_IUI_N3F_V3F_EXT),
    ENUM_MAPPING(GL_T2F_IUI_V2F_EXT),
    ENUM_MAPPING(GL_T2F_IUI_V3F_EXT),
    ENUM_MAPPING(GL_T2F_N3F_V3F),
    ENUM_MAPPING(GL_T2F_V3F),
    ENUM_MAPPING(GL_T4F_C4F_N3F_V4F),
    ENUM_MAPPING(GL_T4F_V4F),
    ENUM_MAPPING(GL_TABLE_TOO_LARGE),
    ENUM_MAPPING(GL_TANGENT_ARRAY_EXT),
    ENUM_MAPPING(GL_TANGENT_ARRAY_POINTER_EXT),
    ENUM_MAPPING(GL_TANGENT_ARRAY_STRIDE_EXT),
    ENUM_MAPPING(GL_TANGENT_ARRAY_TYPE_EXT),
    ENUM_MAPPING(GL_TEXCOORD1_BIT_PGI),
    ENUM_MAPPING(GL_TEXCOORD2_BIT_PGI),
    ENUM_MAPPING(GL_TEXCOORD3_BIT_PGI),
    ENUM_MAPPING(GL_TEXCOORD4_BIT_PGI),
    ENUM_MAPPING(GL_TEXTURE),
    ENUM_MAPPING(GL_TEXTURE_1D),
    ENUM_MAPPING(GL_TEXTURE_1D_ARRAY_EXT),
    ENUM_MAPPING(GL_TEXTURE_1D_BINDING_EXT),
    ENUM_MAPPING(GL_TEXTURE_1D_STACK_BINDING_MESAX),
    ENUM_MAPPING(GL_TEXTURE_1D_STACK_MESAX),
    ENUM_MAPPING(GL_TEXTURE_2D),
    ENUM_MAPPING(GL_TEXTURE_2D_ARRAY_EXT),
    ENUM_MAPPING(GL_TEXTURE_2D_BINDING_EXT),
    ENUM_MAPPING(GL_TEXTURE_2D_STACK_BINDING_MESAX),
    ENUM_MAPPING(GL_TEXTURE_2D_STACK_MESAX),
    ENUM_MAPPING(GL_TEXTURE_CUBE_MAP),
    ENUM_MAPPING(GL_TEXTURE_3D),
    ENUM_MAPPING(GL_TEXTURE_3D_BINDING_EXT),
    ENUM_MAPPING(GL_TEXTURE_4D_BINDING_SGIS),
    ENUM_MAPPING(GL_TEXTURE_4D_SGIS),
    ENUM_MAPPING(GL_TEXTURE_4DSIZE_SGIS),
    ENUM_MAPPING(GL_TEXTURE_ALPHA_SIZE),
    ENUM_MAPPING(GL_TEXTURE_ALPHA_TYPE_ARB),
    ENUM_MAPPING(GL_TEXTURE_APPLICATION_MODE_EXT),
    ENUM_MAPPING(GL_TEXTURE_BASE_LEVEL),
    ENUM_MAPPING(GL_TEXTURE_BINDING_1D),
    ENUM_MAPPING(GL_TEXTURE_BINDING_1D_ARRAY_EXT),
    ENUM_MAPPING(GL_TEXTURE_BINDING_2D),
    ENUM_MAPPING(GL_TEXTURE_BINDING_2D_ARRAY_EXT),
    ENUM_MAPPING(GL_TEXTURE_BINDING_3D),
    ENUM_MAPPING(GL_TEXTURE_BINDING_BUFFER_EXT),
    ENUM_MAPPING(GL_TEXTURE_BINDING_CUBE_MAP),
    ENUM_MAPPING(GL_TEXTURE_BINDING_RECTANGLE_ARB),
    ENUM_MAPPING(GL_TEXTURE_BIT),
    ENUM_MAPPING(GL_TEXTURE_BLUE_SIZE),
    ENUM_MAPPING(GL_TEXTURE_BLUE_TYPE_ARB),
    ENUM_MAPPING(GL_TEXTURE_BORDER),
    ENUM_MAPPING(GL_TEXTURE_BORDER_COLOR),
    ENUM_MAPPING(GL_TEXTURE_BUFFER_DATA_STORE_BINDING_EXT),
    ENUM_MAPPING(GL_TEXTURE_BUFFER_EXT),
    ENUM_MAPPING(GL_TEXTURE_BUFFER_FORMAT_EXT),
    ENUM_MAPPING(GL_TEXTURE_CLIPMAP_CENTER_SGIX),
    ENUM_MAPPING(GL_TEXTURE_CLIPMAP_DEPTH_SGIX),
    ENUM_MAPPING(GL_TEXTURE_CLIPMAP_FRAME_SGIX),
    ENUM_MAPPING(GL_TEXTURE_CLIPMAP_LOD_OFFSET_SGIX),
    ENUM_MAPPING(GL_TEXTURE_CLIPMAP_OFFSET_SGIX),
    ENUM_MAPPING(GL_TEXTURE_CLIPMAP_VIRTUAL_DEPTH_SGIX),
    ENUM_MAPPING(GL_TEXTURE_COLOR_TABLE_SGI),
    ENUM_MAPPING(GL_TEXTURE_COLOR_WRITEMASK_SGIS),
    ENUM_MAPPING(GL_TEXTURE_COMPARE_FAIL_VALUE_ARB),
    ENUM_MAPPING(GL_TEXTURE_COMPARE_FUNC),
    ENUM_MAPPING(GL_TEXTURE_COMPARE_MODE),
    ENUM_MAPPING(GL_TEXTURE_COMPARE_OPERATOR_SGIX),
    ENUM_MAPPING(GL_TEXTURE_COMPARE_SGIX),
    ENUM_MAPPING(GL_TEXTURE_COMPONENTS),
    ENUM_MAPPING(GL_TEXTURE_COMPRESSED_IMAGE_SIZE),
    ENUM_MAPPING(GL_TEXTURE_COMPRESSION_HINT),
    ENUM_MAPPING(GL_TEXTURE_CONSTANT_DATA_SUNX),
    ENUM_MAPPING(GL_TEXTURE_COORD_ARRAY),
    ENUM_MAPPING(GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING),
    ENUM_MAPPING(GL_TEXTURE_COORD_ARRAY_COUNT_EXT),
    //  ENUM_MAPPING( GL_TEXTURE_COORD_ARRAY_EXT ),
    ENUM_MAPPING(GL_TEXTURE_COORD_ARRAY_LIST_IBM),
    ENUM_MAPPING(GL_TEXTURE_COORD_ARRAY_LIST_STRIDE_IBM),
    ENUM_MAPPING(GL_TEXTURE_COORD_ARRAY_PARALLEL_POINTERS_INTEL),
    ENUM_MAPPING(GL_TEXTURE_COORD_ARRAY_POINTER),
    ENUM_MAPPING(GL_TEXTURE_COORD_ARRAY_POINTER_EXT),
    ENUM_MAPPING(GL_TEXTURE_COORD_ARRAY_SIZE),
    ENUM_MAPPING(GL_TEXTURE_COORD_ARRAY_SIZE_EXT),
    ENUM_MAPPING(GL_TEXTURE_COORD_ARRAY_STRIDE),
    ENUM_MAPPING(GL_TEXTURE_COORD_ARRAY_STRIDE_EXT),
    ENUM_MAPPING(GL_TEXTURE_COORD_ARRAY_TYPE),
    ENUM_MAPPING(GL_TEXTURE_COORD_ARRAY_TYPE_EXT),
    ENUM_MAPPING(GL_TEXTURE_CUBE_MAP_NEGATIVE_X),
    ENUM_MAPPING(GL_TEXTURE_CUBE_MAP_NEGATIVE_Y),
    ENUM_MAPPING(GL_TEXTURE_CUBE_MAP_NEGATIVE_Z),
    ENUM_MAPPING(GL_TEXTURE_CUBE_MAP_POSITIVE_X),
    ENUM_MAPPING(GL_TEXTURE_CUBE_MAP_POSITIVE_Y),
    ENUM_MAPPING(GL_TEXTURE_CUBE_MAP_POSITIVE_Z),
    ENUM_MAPPING(GL_TEXTURE_DEFORMATION_BIT_SGIX),
    ENUM_MAPPING(GL_TEXTURE_DEFORMATION_SGIX),
    ENUM_MAPPING(GL_TEXTURE_DEPTH_SIZE),
    ENUM_MAPPING(GL_TEXTURE_DEPTH_TYPE_ARB),
    ENUM_MAPPING(GL_TEXTURE_ENV),
    ENUM_MAPPING(GL_TEXTURE_ENV_BIAS_SGIX),
    ENUM_MAPPING(GL_TEXTURE_ENV_COLOR),
    ENUM_MAPPING(GL_TEXTURE_ENV_MODE),
    ENUM_MAPPING(GL_TEXTURE_FILTER_CONTROL),
    ENUM_MAPPING(GL_TEXTURE_FILTER4_SIZE_SGIS),
    ENUM_MAPPING(GL_TEXTURE_GEN_MODE),
    ENUM_MAPPING(GL_TEXTURE_GEN_Q),
    ENUM_MAPPING(GL_TEXTURE_GEN_R),
    ENUM_MAPPING(GL_TEXTURE_GEN_S),
    ENUM_MAPPING(GL_TEXTURE_GEN_T),
    ENUM_MAPPING(GL_TEXTURE_GEQUAL_R_SGIX),
    ENUM_MAPPING(GL_TEXTURE_GREEN_SIZE),
    ENUM_MAPPING(GL_TEXTURE_HEIGHT),
    ENUM_MAPPING(GL_TEXTURE_INTENSITY_SIZE),
    ENUM_MAPPING(GL_TEXTURE_INTERNAL_FORMAT),
    ENUM_MAPPING(GL_TEXTURE_LEQUAL_R_SGIX),
    ENUM_MAPPING(GL_TEXTURE_LIGHT_EXT),
    ENUM_MAPPING(GL_TEXTURE_LIGHTING_MODE_HP),
    ENUM_MAPPING(GL_TEXTURE_LOD_BIAS_R_SGIX),
    ENUM_MAPPING(GL_TEXTURE_LOD_BIAS_S_SGIX),
    ENUM_MAPPING(GL_TEXTURE_LOD_BIAS_T_SGIX),
    ENUM_MAPPING(GL_TEXTURE_LUMINANCE_SIZE),
    ENUM_MAPPING(GL_TEXTURE_LUMINANCE_TYPE_ARB),
    ENUM_MAPPING(GL_TEXTURE_MAG_FILTER),
    ENUM_MAPPING(GL_TEXTURE_MATERIAL_FACE_EXT),
    ENUM_MAPPING(GL_TEXTURE_MATERIAL_PARAMETER_EXT),
    ENUM_MAPPING(GL_TEXTURE_MATRIX),
    ENUM_MAPPING(GL_TEXTURE_MAX_ANISOTROPY_EXT),
    ENUM_MAPPING(GL_TEXTURE_MAX_CLAMP_R_SGIX),
    ENUM_MAPPING(GL_TEXTURE_MAX_CLAMP_S_SGIX),
    ENUM_MAPPING(GL_TEXTURE_MAX_CLAMP_T_SGIX),
    ENUM_MAPPING(GL_TEXTURE_MAX_LEVEL),
    ENUM_MAPPING(GL_TEXTURE_MAX_LOD),
    ENUM_MAPPING(GL_TEXTURE_MIN_FILTER),
    ENUM_MAPPING(GL_TEXTURE_MIN_LOD),
    ENUM_MAPPING(GL_TEXTURE_MULTI_BUFFER_HINT_SGIX),
    ENUM_MAPPING(GL_TEXTURE_NORMAL_EXT),
    ENUM_MAPPING(GL_TEXTURE_POST_SPECULAR_HP),
    ENUM_MAPPING(GL_TEXTURE_PRE_SPECULAR_HP),
    ENUM_MAPPING(GL_TEXTURE_PRIORITY),
    ENUM_MAPPING(GL_TEXTURE_RECTANGLE_ARB),
    ENUM_MAPPING(GL_TEXTURE_RED_SIZE),
    ENUM_MAPPING(GL_TEXTURE_RED_TYPE_ARB),
    ENUM_MAPPING(GL_TEXTURE_RESIDENT),
    ENUM_MAPPING(GL_TEXTURE_SHARED_SIZE_EXT),
    ENUM_MAPPING(GL_TEXTURE_STACK_DEPTH),
    ENUM_MAPPING(GL_TEXTURE_STENCIL_SIZE_EXT),
    ENUM_MAPPING(GL_TEXTURE_TOO_LARGE_EXT),
    ENUM_MAPPING(GL_TEXTURE_WIDTH),
    ENUM_MAPPING(GL_TEXTURE_WRAP_Q_SGIS),
    ENUM_MAPPING(GL_TEXTURE_WRAP_R_EXT),
    ENUM_MAPPING(GL_TEXTURE_WRAP_S),
    ENUM_MAPPING(GL_TEXTURE_WRAP_T),
    ENUM_MAPPING(GL_TEXTURE0),
    ENUM_MAPPING(GL_TEXTURE1),
    ENUM_MAPPING(GL_TEXTURE2),
    ENUM_MAPPING(GL_TEXTURE3),
    ENUM_MAPPING(GL_TEXTURE4),
    ENUM_MAPPING(GL_TEXTURE5),
    ENUM_MAPPING(GL_TEXTURE6),
    ENUM_MAPPING(GL_TEXTURE7),
    ENUM_MAPPING(GL_TEXTURE8),
    ENUM_MAPPING(GL_TEXTURE9),
    ENUM_MAPPING(GL_TEXTURE10),
    ENUM_MAPPING(GL_TEXTURE11),
    ENUM_MAPPING(GL_TEXTURE12),
    ENUM_MAPPING(GL_TEXTURE13),
    ENUM_MAPPING(GL_TEXTURE14),
    ENUM_MAPPING(GL_TEXTURE15),
    ENUM_MAPPING(GL_TEXTURE16),
    ENUM_MAPPING(GL_TEXTURE17),
    ENUM_MAPPING(GL_TEXTURE18),
    ENUM_MAPPING(GL_TEXTURE19),
    ENUM_MAPPING(GL_TEXTURE20),
    ENUM_MAPPING(GL_TEXTURE21),
    ENUM_MAPPING(GL_TEXTURE22),
    ENUM_MAPPING(GL_TEXTURE23),
    ENUM_MAPPING(GL_TEXTURE24),
    ENUM_MAPPING(GL_TEXTURE25),
    ENUM_MAPPING(GL_TEXTURE26),
    ENUM_MAPPING(GL_TEXTURE27),
    ENUM_MAPPING(GL_TEXTURE28),
    ENUM_MAPPING(GL_TEXTURE29),
    ENUM_MAPPING(GL_TEXTURE30),
    ENUM_MAPPING(GL_TEXTURE31),
    ENUM_MAPPING(GL_TIME_ELAPSED_EXT),
    ENUM_MAPPING(GL_TRANSFORM_BIT),
    ENUM_MAPPING(GL_TRANSFORM_HINT_APPLE),
    ENUM_MAPPING(GL_TRANSPOSE_COLOR_MATRIX),
    ENUM_MAPPING(GL_TRANSPOSE_CURRENT_MATRIX_ARB),
    ENUM_MAPPING(GL_TRANSPOSE_MODELVIEW_MATRIX),
    ENUM_MAPPING(GL_TRANSPOSE_PROJECTION_MATRIX),
    ENUM_MAPPING(GL_TRANSPOSE_TEXTURE_MATRIX),
    ENUM_MAPPING(GL_TRIANGLE_FAN),
    ENUM_MAPPING(GL_TRIANGLE_LIST_SUN),
    ENUM_MAPPING(GL_TRIANGLE_MESH_SUN),
    ENUM_MAPPING(GL_TRIANGLE_STRIP),
    ENUM_MAPPING(GL_TRIANGLE_STRIP_ADJACENCY_EXT),
    ENUM_MAPPING(GL_TRIANGLES),
    ENUM_MAPPING(GL_TRIANGLES_ADJACENCY_EXT),
    ENUM_MAPPING(GL_TRUE),
    ENUM_MAPPING(GL_UNIFORM_BUFFER_BINDING_EXT),
    ENUM_MAPPING(GL_UNIFORM_BUFFER_EXT),
    ENUM_MAPPING(GL_UNPACK_ALIGNMENT),
    ENUM_MAPPING(GL_UNPACK_CLIENT_STORAGE_APPLE),
    ENUM_MAPPING(GL_UNPACK_CMYK_HINT_EXT),
    ENUM_MAPPING(GL_UNPACK_CONSTANT_DATA_SUNX),
    ENUM_MAPPING(GL_UNPACK_IMAGE_DEPTH_SGIS),
    ENUM_MAPPING(GL_UNPACK_IMAGE_HEIGHT),
    ENUM_MAPPING(GL_UNPACK_LSB_FIRST),
    ENUM_MAPPING(GL_UNPACK_RESAMPLE_OML),
    ENUM_MAPPING(GL_UNPACK_RESAMPLE_SGIX),
    ENUM_MAPPING(GL_UNPACK_ROW_LENGTH),
    ENUM_MAPPING(GL_UNPACK_SKIP_IMAGES),
    ENUM_MAPPING(GL_UNPACK_SKIP_PIXELS),
    ENUM_MAPPING(GL_UNPACK_SKIP_ROWS),
    ENUM_MAPPING(GL_UNPACK_SKIP_VOLUMES_SGIS),
    ENUM_MAPPING(GL_UNPACK_SUBSAMPLE_RATE_SGIX),
    ENUM_MAPPING(GL_UNPACK_SWAP_BYTES),
    ENUM_MAPPING(GL_UNSIGNED_BYTE),
    ENUM_MAPPING(GL_UNSIGNED_BYTE_2_3_3_REV),
    ENUM_MAPPING(GL_UNSIGNED_BYTE_3_3_2_EXT),
    ENUM_MAPPING(GL_UNSIGNED_INT),
    ENUM_MAPPING(GL_UNSIGNED_INT_10_10_10_2_EXT),
    ENUM_MAPPING(GL_UNSIGNED_INT_10F_11F_11F_REV_EXT),
    ENUM_MAPPING(GL_UNSIGNED_INT_2_10_10_10_REV),
    ENUM_MAPPING(GL_UNSIGNED_INT_24_8_EXT),
    ENUM_MAPPING(GL_UNSIGNED_INT_5_9_9_9_REV_EXT),
    ENUM_MAPPING(GL_UNSIGNED_INT_8_8_8_8_EXT),
    ENUM_MAPPING(GL_UNSIGNED_INT_8_8_8_8_REV),
    ENUM_MAPPING(GL_UNSIGNED_INT_SAMPLER_1D_ARRAY_EXT),
    ENUM_MAPPING(GL_UNSIGNED_INT_SAMPLER_1D_EXT),
    ENUM_MAPPING(GL_UNSIGNED_INT_SAMPLER_2D_ARRAY_EXT),
    ENUM_MAPPING(GL_UNSIGNED_INT_SAMPLER_2D_EXT),
    ENUM_MAPPING(GL_UNSIGNED_INT_SAMPLER_2D_RECT_EXT),
    ENUM_MAPPING(GL_UNSIGNED_INT_SAMPLER_3D_EXT),
    ENUM_MAPPING(GL_UNSIGNED_INT_SAMPLER_BUFFER_EXT),
    ENUM_MAPPING(GL_UNSIGNED_INT_SAMPLER_CUBE_EXT),
    ENUM_MAPPING(GL_UNSIGNED_INT_VEC2_EXT),
    ENUM_MAPPING(GL_UNSIGNED_INT_VEC3_EXT),
    ENUM_MAPPING(GL_UNSIGNED_INT_VEC4_EXT),
    ENUM_MAPPING(GL_UNSIGNED_NORMALIZED_ARB),
    ENUM_MAPPING(GL_UNSIGNED_SHORT),
    ENUM_MAPPING(GL_UNSIGNED_SHORT_1_5_5_5_REV),
    ENUM_MAPPING(GL_UNSIGNED_SHORT_4_4_4_4_EXT),
    ENUM_MAPPING(GL_UNSIGNED_SHORT_4_4_4_4_REV),
    ENUM_MAPPING(GL_UNSIGNED_SHORT_5_5_5_1_EXT),
    ENUM_MAPPING(GL_UNSIGNED_SHORT_5_6_5_REV),
    ENUM_MAPPING(GL_UNSIGNED_SHORT_8_8_APPLE),
    ENUM_MAPPING(GL_UNSIGNED_SHORT_8_8_MESA),
    ENUM_MAPPING(GL_UNSIGNED_SHORT_8_8_REV_APPLE),
    ENUM_MAPPING(GL_UNSIGNED_SHORT_8_8_REV_MESA),
    ENUM_MAPPING(GL_UPPER_LEFT),
    ENUM_MAPPING(GL_V2F),
    ENUM_MAPPING(GL_V3F),
    ENUM_MAPPING(GL_VALIDATE_STATUS),
    ENUM_MAPPING(GL_VARIANT_ARRAY_EXT),
    ENUM_MAPPING(GL_VARIANT_ARRAY_POINTER_EXT),
    ENUM_MAPPING(GL_VARIANT_ARRAY_STRIDE_EXT),
    ENUM_MAPPING(GL_VARIANT_ARRAY_TYPE_EXT),
    ENUM_MAPPING(GL_VARIANT_DATATYPE_EXT),
    ENUM_MAPPING(GL_VARIANT_EXT),
    ENUM_MAPPING(GL_VARIANT_VALUE_EXT),
    ENUM_MAPPING(GL_VECTOR_EXT),
    ENUM_MAPPING(GL_VENDOR),
    ENUM_MAPPING(GL_VERSION),
    ENUM_MAPPING(GL_VERTEX_ARRAY),
    ENUM_MAPPING(GL_VERTEX_ARRAY_BINDING_APPLE),
    ENUM_MAPPING(GL_VERTEX_ARRAY_BUFFER_BINDING),
    ENUM_MAPPING(GL_VERTEX_ARRAY_COUNT_EXT),
    //  ENUM_MAPPING( GL_VERTEX_ARRAY_EXT ),
    ENUM_MAPPING(GL_VERTEX_ARRAY_LIST_IBM),
    ENUM_MAPPING(GL_VERTEX_ARRAY_LIST_STRIDE_IBM),
    ENUM_MAPPING(GL_VERTEX_ARRAY_PARALLEL_POINTERS_INTEL),
    ENUM_MAPPING(GL_VERTEX_ARRAY_POINTER),
    ENUM_MAPPING(GL_VERTEX_ARRAY_POINTER_EXT),
    ENUM_MAPPING(GL_VERTEX_ARRAY_RANGE_APPLE),
    ENUM_MAPPING(GL_VERTEX_ARRAY_RANGE_LENGTH_APPLE),
    ENUM_MAPPING(GL_VERTEX_ARRAY_RANGE_POINTER_APPLE),
    ENUM_MAPPING(GL_VERTEX_ARRAY_SIZE),
    ENUM_MAPPING(GL_VERTEX_ARRAY_SIZE_EXT),
    ENUM_MAPPING(GL_VERTEX_ARRAY_STORAGE_HINT_APPLE),
    ENUM_MAPPING(GL_VERTEX_ARRAY_STRIDE),
    ENUM_MAPPING(GL_VERTEX_ARRAY_STRIDE_EXT),
    ENUM_MAPPING(GL_VERTEX_ARRAY_TYPE),
    ENUM_MAPPING(GL_VERTEX_ARRAY_TYPE_EXT),
    ENUM_MAPPING(GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING),
    ENUM_MAPPING(GL_VERTEX_ATTRIB_ARRAY_ENABLED),
    ENUM_MAPPING(GL_VERTEX_ATTRIB_ARRAY_NORMALIZED),
    ENUM_MAPPING(GL_VERTEX_ATTRIB_ARRAY_POINTER),
    ENUM_MAPPING(GL_VERTEX_ATTRIB_ARRAY_SIZE),
    ENUM_MAPPING(GL_VERTEX_ATTRIB_ARRAY_STRIDE),
    ENUM_MAPPING(GL_VERTEX_ATTRIB_ARRAY_TYPE),
    ENUM_MAPPING(GL_VERTEX_BLEND_ARB),
    ENUM_MAPPING(GL_VERTEX_CONSISTENT_HINT_PGI),
    ENUM_MAPPING(GL_VERTEX_DATA_HINT_PGI),
    ENUM_MAPPING(GL_VERTEX_PRECLIP_HINT_SGIX),
    ENUM_MAPPING(GL_VERTEX_PRECLIP_SGIX),
    ENUM_MAPPING(GL_VERTEX_PROGRAM_ARB),
    ENUM_MAPPING(GL_VERTEX_PROGRAM_POINT_SIZE),
    ENUM_MAPPING(GL_VERTEX_PROGRAM_TWO_SIDE),
    ENUM_MAPPING(GL_VERTEX_SHADER_BINDING_EXT),
    ENUM_MAPPING(GL_VERTEX_SHADER_INSTRUCTIONS_EXT),
    ENUM_MAPPING(GL_VERTEX_SHADER_INVARIANTS_EXT),
    ENUM_MAPPING(GL_VERTEX_SHADER_LOCAL_CONSTANTS_EXT),
    ENUM_MAPPING(GL_VERTEX_SHADER_LOCALS_EXT),
    ENUM_MAPPING(GL_VERTEX_SHADER_OPTIMIZED_EXT),
    ENUM_MAPPING(GL_VERTEX_SHADER_VARIANTS_EXT),
    ENUM_MAPPING(GL_VERTEX_WEIGHT_ARRAY_EXT),
    ENUM_MAPPING(GL_VERTEX_WEIGHT_ARRAY_POINTER_EXT),
    ENUM_MAPPING(GL_VERTEX_WEIGHT_ARRAY_SIZE_EXT),
    ENUM_MAPPING(GL_VERTEX_WEIGHT_ARRAY_STRIDE_EXT),
    ENUM_MAPPING(GL_VERTEX_WEIGHT_ARRAY_TYPE_EXT),
    ENUM_MAPPING(GL_VERTEX_WEIGHTING_EXT),
    ENUM_MAPPING(GL_VERTEX23_BIT_PGI),
    ENUM_MAPPING(GL_VERTEX4_BIT_PGI),
    ENUM_MAPPING(GL_VIEWPORT),
    ENUM_MAPPING(GL_VIEWPORT_BIT),
    ENUM_MAPPING(GL_W_EXT),
    ENUM_MAPPING(GL_WEIGHT_ARRAY_ARB),
    ENUM_MAPPING(GL_WEIGHT_ARRAY_BUFFER_BINDING),
    ENUM_MAPPING(GL_WEIGHT_ARRAY_POINTER_ARB),
    ENUM_MAPPING(GL_WEIGHT_ARRAY_SIZE_ARB),
    ENUM_MAPPING(GL_WEIGHT_ARRAY_STRIDE_ARB),
    ENUM_MAPPING(GL_WEIGHT_ARRAY_TYPE_ARB),
    ENUM_MAPPING(GL_WEIGHT_SUM_UNITY_ARB),
    ENUM_MAPPING(GL_WIDE_LINE_HINT_PGI),
    ENUM_MAPPING(GL_WRAP_BORDER_SUN),
    ENUM_MAPPING(GL_WRITE_ONLY),
    ENUM_MAPPING(GL_X_EXT),
    ENUM_MAPPING(GL_XOR),
    ENUM_MAPPING(GL_Y_EXT),
    ENUM_MAPPING(GL_YCBCR_422_APPLE),
    ENUM_MAPPING(GL_YCBCR_MESA),
    ENUM_MAPPING(GL_YCRCB_422_SGIX),
    ENUM_MAPPING(GL_YCRCB_444_SGIX),
    ENUM_MAPPING(GL_YCRCB_SGIX),
    ENUM_MAPPING(GL_YCRCBA_SGIX),
    ENUM_MAPPING(GL_Z_EXT),
    ENUM_MAPPING(GL_ZERO),
    ENUM_MAPPING(GL_ZOOM_X),
    ENUM_MAPPING(GL_ZOOM_Y),
    /*  TODO: g++ seem to pick GL/glext.h instead of our custom glext.h
  ENUM_MAPPING( GL_COLOR_TABLE_ALPHA_SIZE_EXT ),
  ENUM_MAPPING( GL_COLOR_TABLE_BLUE_SIZE_EXT ),
  ENUM_MAPPING( GL_COLOR_TABLE_FORMAT_EXT ),
  ENUM_MAPPING( GL_COLOR_TABLE_GREEN_SIZE_EXT ),
  ENUM_MAPPING( GL_COLOR_TABLE_INTENSITY_SIZE_EXT ),
  ENUM_MAPPING( GL_COLOR_TABLE_LUMINANCE_SIZE_EXT ),
  ENUM_MAPPING( GL_COLOR_TABLE_RED_SIZE_EXT ),
  ENUM_MAPPING( GL_COLOR_TABLE_WIDTH_EXT ),
  ENUM_MAPPING( GL_DOUBLE_EXT ),
  ENUM_MAPPING( GL_MAX_ELEMENTS_INDICES_WIN ),
  ENUM_MAPPING( GL_MAX_ELEMENTS_VERTICES_WIN )
*/
    ENUM_MAPPING(GL_SHADER_INCLUDE_ARB),
    ENUM_MAPPING(GL_NAMED_STRING_LENGTH_ARB),
    ENUM_MAPPING(GL_NAMED_STRING_TYPE_ARB),
    ENUM_MAPPING(GL_MAX_DUAL_SOURCE_DRAW_BUFFERS),
    ENUM_MAPPING(GL_TEXTURE_BUFFER),
    ENUM_MAPPING(GL_TEXTURE_BINDING_BUFFER),
};
#undef ENUM_MAPPING

std::string gits::OpenGL::CGLenum::EnumString(GLenum value) {
  typedef std::multimap<GLenum, const char*> CEnumMap;
  INIT_NEW_STATIC_OBJ(enumMap, CEnumMap)
  // initialize enum map
  if (enumMap.empty()) {
    for (auto& enum_pair : _enumNames) {
      enumMap.insert(std::make_pair(enum_pair.value, enum_pair.name));
    }
  }
  CEnumMap::const_iterator lower = enumMap.lower_bound(value);
  CEnumMap::const_iterator upper = enumMap.upper_bound(value);

  if (lower == upper) {
    std::stringstream retval;
    retval << std::showbase << std::setfill('0') << std::setw(4) << std::hex << std::internal
           << value;
    return retval.str();
  }

  std::stringstream retval;
  retval << lower->second;
  for (++lower; lower != upper; ++lower) {
    retval << " | " << lower->second;
  }
  return retval.str();
}

/* ******************************** B O O L E A N ****************************** */

const char* gits::OpenGL::CGLboolean::NAME = "GLboolean";

gits::OpenGL::CGLboolean::CGLboolean() : CGLtype<GLtype, type>() {}

gits::OpenGL::CGLboolean::CGLboolean(GLboolean value) : CGLtype<GLtype, type>(value) {}

void gits::OpenGL::CGLboolean::Write(CCodeOStream& stream) const {
  if (Value()) {
    stream << "GL_TRUE";
  } else {
    stream << "GL_FALSE";
  }
}

/* ******************************* B I T F I E L D ***************************** */

const char* gits::OpenGL::CGLbitfield::NAME = "GLbitfield";

gits::OpenGL::CGLbitfield::CGLbitfield() : CGLtype<GLtype, type>() {}

gits::OpenGL::CGLbitfield::CGLbitfield(GLbitfield value) : CGLtype<GLtype, type>(value) {}

void gits::OpenGL::CGLbitfield::Write(CCodeOStream& stream) const {
  std::ios_base::fmtflags streamFlags(stream.flags());
  stream << std::setfill('0') << std::hex << std::setw(LENGTH * 2) << std::internal << Value();
  stream.flags(streamFlags);
}

/* *********************************** B Y T E ********************************* */

const char* gits::OpenGL::CGLbyte::NAME = "GLbyte";

gits::OpenGL::CGLbyte::CGLbyte() : CGLtype<GLtype, type>() {}

gits::OpenGL::CGLbyte::CGLbyte(GLbyte value) : CGLtype<GLtype, type>(value) {}

void gits::OpenGL::CGLbyte::Write(CCodeOStream& stream) const {
  std::ios_base::fmtflags streamFlags(stream.flags());
  stream << std::dec << int(Value());
  stream.flags(streamFlags);
}

/* ********************************** S H O R T ******************************** */

const char* gits::OpenGL::CGLshort::NAME = "GLshort";

gits::OpenGL::CGLshort::CGLshort() : CGLtype<GLtype, type>() {}

gits::OpenGL::CGLshort::CGLshort(GLshort value) : CGLtype<GLtype, type>(value) {}

void gits::OpenGL::CGLshort::Write(CCodeOStream& stream) const {
  std::ios_base::fmtflags streamFlags(stream.flags());
  stream << std::dec << Value();
  stream.flags(streamFlags);
}

/* ************************************ I N T ********************************** */

const char* gits::OpenGL::CGLint::NAME = "GLint";

gits::OpenGL::CGLint::CGLint() : CGLtype<GLtype, type>() {}

gits::OpenGL::CGLint::CGLint(GLint value) : CGLtype<GLtype, type>(value) {}

void gits::OpenGL::CGLint::Write(CCodeOStream& stream) const {
  std::ios_base::fmtflags streamFlags(stream.flags());
  stream << std::dec << Value();
  stream.flags(streamFlags);
}

/* ************************************ I N T 6 4 ********************************** */

const char* gits::OpenGL::CGLint64::NAME = "GLint64";

gits::OpenGL::CGLint64::CGLint64() : CGLtype<GLtype, type>() {}

gits::OpenGL::CGLint64::CGLint64(GLint64 value) : CGLtype<GLtype, type>(value) {}

void gits::OpenGL::CGLint64::Write(CCodeOStream& stream) const {
  std::ios_base::fmtflags streamFlags(stream.flags());
  stream << std::dec << Value();
  stream.flags(streamFlags);
}

/* ********************************** S I Z E I ******************************** */

const char* gits::OpenGL::CGLsizei::NAME = "GLsizei";

gits::OpenGL::CGLsizei::CGLsizei() : CGLtype<GLtype, type>() {}

gits::OpenGL::CGLsizei::CGLsizei(GLsizei value) : CGLtype<GLtype, type>(value) {}

void gits::OpenGL::CGLsizei::Write(CCodeOStream& stream) const {
  std::ios_base::fmtflags streamFlags(stream.flags());
  stream << std::dec << Value();
  stream.flags(streamFlags);
}

/* ********************************** U B Y T E ******************************** */

const char* gits::OpenGL::CGLubyte::NAME = "GLubyte";

gits::OpenGL::CGLubyte::CGLubyte() : CGLtype<GLtype, type>() {}

gits::OpenGL::CGLubyte::CGLubyte(GLubyte value) : CGLtype<GLtype, type>(value) {}

void gits::OpenGL::CGLubyte::Write(CCodeOStream& stream) const {
  std::ios_base::fmtflags streamFlags(stream.flags());
  stream << std::dec << unsigned(Value());
  stream.flags(streamFlags);
}

/* ********************************* U S H O R T ******************************* */

const char* gits::OpenGL::CGLushort::NAME = "GLushort";

gits::OpenGL::CGLushort::CGLushort() : CGLtype<GLtype, type>() {}

gits::OpenGL::CGLushort::CGLushort(GLushort value) : CGLtype<GLtype, type>(value) {}

void gits::OpenGL::CGLushort::Write(CCodeOStream& stream) const {
  std::ios_base::fmtflags streamFlags(stream.flags());
  stream << std::dec << Value();
  stream.flags(streamFlags);
}

/* *********************************** U I N T ********************************* */

const char* gits::OpenGL::CGLuint::NAME = "GLuint";

gits::OpenGL::CGLuint::CGLuint() : CGLtype<GLtype, type>() {}

gits::OpenGL::CGLuint::CGLuint(GLuint value) : CGLtype<GLtype, type>(value) {}

void gits::OpenGL::CGLuint::Write(CCodeOStream& stream) const {
  std::ios_base::fmtflags streamFlags(stream.flags());
  stream << std::dec << Value();
  stream.flags(streamFlags);
}

/* *********************************** U I N T 6 4 ********************************* */

const char* gits::OpenGL::CGLuint64::NAME = "GLuint64";

gits::OpenGL::CGLuint64::CGLuint64() : CGLtype<GLtype, type>() {}

gits::OpenGL::CGLuint64::CGLuint64(GLuint64 value) : CGLtype<GLtype, type>(value) {}

void gits::OpenGL::CGLuint64::Write(CCodeOStream& stream) const {
  std::ios_base::fmtflags streamFlags(stream.flags());
  stream << std::dec << Value();
  stream.flags(streamFlags);
}

/* ********************************** F L O A T ******************************** */

const char* gits::OpenGL::CGLfloat::NAME = "GLfloat";

gits::OpenGL::CGLfloat::CGLfloat() : CGLtype<GLtype, type>() {}

gits::OpenGL::CGLfloat::CGLfloat(GLfloat value) : CGLtype<GLtype, type>(value) {}

void gits::OpenGL::CGLfloat::Write(CCodeOStream& stream) const {
  GLfloat value = Value();
  std::ios_base::fmtflags streamFlags(stream.flags());

  if (value != value) {
    // NaN - give any valid value
    stream << 0;
  } else {
    // cap value to min/max - discard infinities
    // bizzare parenthesis usage prevents min/max windows macros from kicking in
    value = (std::min)((std::numeric_limits<GLfloat>::max)(), value);
    value = (std::max)(-(std::numeric_limits<GLfloat>::max)(), value);

    stream << std::showpoint << value << 'f';
  }
  stream.flags(streamFlags);
}

/* ********************************* C L A M P F ******************************* */

const char* gits::OpenGL::CGLclampf::NAME = "GLclampf";

gits::OpenGL::CGLclampf::CGLclampf() : CGLtype<GLtype, type>() {}

gits::OpenGL::CGLclampf::CGLclampf(GLclampf value) : CGLtype<GLtype, type>(value) {}

void gits::OpenGL::CGLclampf::Write(CCodeOStream& stream) const {
  std::ios_base::fmtflags streamFlags(stream.flags());
  stream << std::showpoint << Value() << 'f';
  stream.flags(streamFlags);
}

/* ********************************* D O U B L E ******************************* */

const char* gits::OpenGL::CGLdouble::NAME = "GLdouble";

gits::OpenGL::CGLdouble::CGLdouble() : CGLtype<GLtype, type>() {}

gits::OpenGL::CGLdouble::CGLdouble(GLdouble value) : CGLtype<GLtype, type>(value) {}

void gits::OpenGL::CGLdouble::Write(CCodeOStream& stream) const {
  std::ios_base::fmtflags streamFlags(stream.flags());
  stream << std::showpoint << std::setprecision(std::numeric_limits<GLdouble>::digits10 + 2)
         << Value() << std::setprecision(std::numeric_limits<float>::digits10);
  stream.flags(streamFlags);
}

/* ********************************* C L A M P D ******************************* */

const char* gits::OpenGL::CGLclampd::NAME = "GLclampd";

gits::OpenGL::CGLclampd::CGLclampd() : CGLtype<GLtype, type>() {}

gits::OpenGL::CGLclampd::CGLclampd(GLclampd value) : CGLtype<GLtype, type>(value) {}

void gits::OpenGL::CGLclampd::Write(CCodeOStream& stream) const {
  std::ios_base::fmtflags streamFlags(stream.flags());
  stream << std::showpoint << std::setprecision(std::numeric_limits<GLclampd>::digits10 + 2)
         << Value() << std::setprecision(std::numeric_limits<float>::digits10);
  stream.flags(streamFlags);
}

/* ******************************** C H A R A R B ****************************** */

const char* gits::OpenGL::CGLcharARB::NAME = "GLcharARB";

gits::OpenGL::CGLcharARB::CGLcharARB() : CGLtype<GLtype, type>() {}

gits::OpenGL::CGLcharARB::CGLcharARB(GLcharARB value) : CGLtype<GLtype, type>(value) {}

void gits::OpenGL::CGLcharARB::Write(CCodeOStream& stream) const {
  std::ios_base::fmtflags streamFlags(stream.flags());
  stream << std::dec << static_cast<int>(Value());
  stream.flags(streamFlags);
}

/* ********************************* C H A R ******************************* */

const char* gits::OpenGL::CGLchar::NAME = "GLchar";

gits::OpenGL::CGLchar::CGLchar() : CGLtype<GLtype, type>() {}

gits::OpenGL::CGLchar::CGLchar(GLchar value) : CGLtype<GLtype, type>(value) {}

void gits::OpenGL::CGLchar::Write(CCodeOStream& stream) const {
  std::ios_base::fmtflags streamFlags(stream.flags());
  stream << std::dec << static_cast<int>(Value());
  stream.flags(streamFlags);
}

/* ********************************* I N T P T R ******************************* */

const char* gits::OpenGL::CGLsizeiptr::NAME = "GLsizeiptr";

gits::OpenGL::CGLsizeiptr::CGLsizeiptr() : CGLtype<GLtype, type>() {}

gits::OpenGL::CGLsizeiptr::CGLsizeiptr(GLsizeiptr value)
    : CGLtype<GLtype, type>(ensure_signed32bit_representible<GLsizeiptr>(value)) {}

void gits::OpenGL::CGLsizeiptr::Write(CCodeOStream& stream) const {
  std::ios_base::fmtflags streamFlags(stream.flags());
  stream << std::dec << Value();
  stream.flags(streamFlags);
}

/* ********************************* H A L F N V ******************************* */

const char* gits::OpenGL::CGLhalfNV::NAME = "GLhalfNV";

gits::OpenGL::CGLhalfNV::CGLhalfNV() : CGLtype<GLtype, type>() {}

gits::OpenGL::CGLhalfNV::CGLhalfNV(GLhalfNV value) : CGLtype<GLtype, type>(value) {}

void gits::OpenGL::CGLhalfNV::Write(CCodeOStream& stream) const {
  std::ios_base::fmtflags streamFlags(stream.flags());
  stream << std::dec << Value();
  stream.flags(streamFlags);
}

/* ********************************* H A N D L E A R B ******************************* */

const char* gits::OpenGL::CGLhandleARB::NAME = "GLhandleARB";

gits::OpenGL::CGLhandleARB::CGLhandleARB() : CGLtype<GLtype, type>() {}

gits::OpenGL::CGLhandleARB::CGLhandleARB(GLhandleARB value) : CGLtype<GLtype, type>(value) {}

void gits::OpenGL::CGLhandleARB::Write(CCodeOStream& stream) const {
  std::ios_base::fmtflags streamFlags(stream.flags());
  stream << std::hex << Value();
  stream.flags(streamFlags);
}

/* ********************************* I N T P T R ******************************* */

const char* gits::OpenGL::CGLintptr::NAME = "GLintptr";

gits::OpenGL::CGLintptr::CGLintptr() : CGLtype<GLtype, type>() {}

gits::OpenGL::CGLintptr::CGLintptr(GLintptr value)
    : CGLtype<GLtype, type>(ensure_signed32bit_representible<GLintptr>(value)) {}

void gits::OpenGL::CGLintptr::Write(CCodeOStream& stream) const {
  std::ios_base::fmtflags streamFlags(stream.flags());
  stream << std::hex << Value();
  stream.flags(streamFlags);
}

/* ********************************* GLint64EXT ******************************* */

const char* gits::OpenGL::CGLint64EXT::NAME = "GLint64EXT";

gits::OpenGL::CGLint64EXT::CGLint64EXT() : CGLtype<GLtype, type>() {}

gits::OpenGL::CGLint64EXT::CGLint64EXT(GLint64EXT value) : CGLtype<GLtype, type>(value) {}

void gits::OpenGL::CGLint64EXT::Write(CCodeOStream& stream) const {
  std::ios_base::fmtflags streamFlags(stream.flags());
  stream << std::hex << Value();
  stream.flags(streamFlags);
}

/* ********************************* GLuint64EXT ******************************* */

const char* gits::OpenGL::CGLuint64EXT::NAME = "GLuint64EXT";

gits::OpenGL::CGLuint64EXT::CGLuint64EXT() : CGLtype<GLtype, type>() {}

gits::OpenGL::CGLuint64EXT::CGLuint64EXT(GLuint64EXT value) : CGLtype<GLtype, type>(value) {}

void gits::OpenGL::CGLuint64EXT::Write(CCodeOStream& stream) const {
  std::ios_base::fmtflags streamFlags(stream.flags());
  stream << std::hex << Value();
  stream.flags(streamFlags);
}

/* ********************************* S I Z E I P T R A R B ******************************* */

const char* gits::OpenGL::CGLsizeiptrARB::NAME = "GLsizeiptrARB";

gits::OpenGL::CGLsizeiptrARB::CGLsizeiptrARB() : CGLtype<GLtype, type>() {}

gits::OpenGL::CGLsizeiptrARB::CGLsizeiptrARB(GLsizeiptrARB value)
    : CGLtype<GLtype, type>(ensure_signed32bit_representible<GLsizeiptrARB>(value)) {}

void gits::OpenGL::CGLsizeiptrARB::Write(CCodeOStream& stream) const {
  std::ios_base::fmtflags streamFlags(stream.flags());
  stream << std::dec << Value();
  stream.flags(streamFlags);
}

/* ********************************* I N T P T R A R B ******************************* */

const char* gits::OpenGL::CGLintptrARB::NAME = "GLintptrARB";

gits::OpenGL::CGLintptrARB::CGLintptrARB() : CGLtype<GLtype, type>() {}

gits::OpenGL::CGLintptrARB::CGLintptrARB(GLintptrARB value)
    : CGLtype<GLtype, type>(ensure_signed32bit_representible<GLintptrARB>(value)) {}

void gits::OpenGL::CGLintptrARB::Write(CCodeOStream& stream) const {
  std::ios_base::fmtflags streamFlags(stream.flags());
  stream << std::hex << Value();
  stream.flags(streamFlags);
}

/* ********************************* V O I D _ P T R ******************************* */

const char* gits::OpenGL::CGLvoid_ptr::NAME = "void *";

gits::OpenGL::CGLvoid_ptr::CGLvoid_ptr() : CGLtype<GLtype, type>() {}

gits::OpenGL::CGLvoid_ptr::CGLvoid_ptr(GLvoid* value)
    : CGLtype<GLtype, type>(reinterpret_cast<uint64_t>(value)) {}

gits::OpenGL::CGLvoid_ptr::CGLvoid_ptr(const GLvoid* value)
    : CGLtype<GLtype, type>(reinterpret_cast<uint64_t>(value)) {}

void gits::OpenGL::CGLvoid_ptr::Write(CCodeOStream& stream) const {
  std::ios_base::fmtflags streamFlags(stream.flags());
  stream << std::hex << "(void *)" << _value;
  stream.flags(streamFlags);
}

/* ********************************* CGLMAPPEDTEXTUREPTR ******************************* */
void gits::OpenGL::CGLMappedTexturePtr::Assign(const void* val) {
  _mappedValue = const_cast<GLvoid*>(val);
}

GLvoid* gits::OpenGL::CGLMappedTexturePtr::Value() {
  return _mappedValue;
}

GLvoid* const gits::OpenGL::CGLMappedTexturePtr::Value() const {
  return _mappedValue;
}

GLvoid* gits::OpenGL::CGLMappedTexturePtr::operator*() {
  return Value();
}

GLvoid* const gits::OpenGL::CGLMappedTexturePtr::operator*() const {
  return Value();
}

/* ********************************* CONST CHAR _ P T R ******************************* */
const char* gits::OpenGL::CGLconstuchar_ptr::NAME = "const unsigned char*";

gits::OpenGL::CGLconstuchar_ptr::CGLconstuchar_ptr() : CGLtype<GLtype, type>() {}

gits::OpenGL::CGLconstuchar_ptr::CGLconstuchar_ptr(const unsigned char* value)
    : CGLtype<GLtype, type>(reinterpret_cast<uint64_t>(value)) {}

void gits::OpenGL::CGLconstuchar_ptr::Write(CCodeOStream& stream) const {
  std::ios_base::fmtflags streamFlags(stream.flags());
  stream << std::hex << "(const unsigned char *)" << _value;
  stream.flags(streamFlags);
}

/* ********************************* V O I D P T R ******************************* */

const char* gits::OpenGL::CGLvoidPtr::NAME = "void *";

gits::OpenGL::CGLvoidPtr::CGLvoidPtr() : _value(0) {}

gits::OpenGL::CGLvoidPtr::CGLvoidPtr(GLvoid* value)
    : _value(ensure_unsigned32bit_representible<uintptr_t>(reinterpret_cast<uintptr_t>(value))) {}

void gits::OpenGL::CGLvoidPtr::Write(CCodeOStream& stream) const {
  std::ios_base::fmtflags streamFlags(stream.flags());
  stream << std::hex << _value;
  stream.flags(streamFlags);
}

/* ********************************* C O N S T V O I D P T R ******************************* */

const char* gits::OpenGL::CGLconstVoidPtr::NAME = "const VoidPointer";

gits::OpenGL::CGLconstVoidPtr::CGLconstVoidPtr() : _value(0) {}

gits::OpenGL::CGLconstVoidPtr::CGLconstVoidPtr(const GLvoid* value)
    : _value(ensure_unsigned32bit_representible<uintptr_t>(reinterpret_cast<uintptr_t>(value))) {}

void gits::OpenGL::CGLconstVoidPtr::Write(CCodeOStream& stream) const {
  std::ios_base::fmtflags streamFlags(stream.flags());
  stream << std::hex << _value;
  stream.flags(streamFlags);
}

/* ********************************** CShaderSource **************************** */

unsigned gits::OpenGL::CShaderSource::_shaderSourceIdx = 0;
unsigned gits::OpenGL::CShaderSource::_shaderProgramIdx = 0;
unsigned gits::OpenGL::CShaderSource::_programStringIdx = 0;
std::string gits::OpenGL::CShaderSource::GetFileName(ShaderType shaderType,
                                                     GLenum target,
                                                     GLenum format,
                                                     GLuint shaderObj) {
  std::stringstream stream;
  if (shaderType == SHADER_SOURCE) {
    // obtain shader type
    GLint type = 999;
    drv.gl.glGetShaderiv(shaderObj, GL_SHADER_TYPE, &type);
    const char* typeAbrv = shaderTypeAbrvName(type);

    stream << "gitsPrograms/" << typeAbrv << "_shader_" << std::setfill('0') << std::setw(2)
           << _shaderSourceIdx++ << ".txt";
  } else if (shaderType == SHADER_PROGRAM) {
    stream << "gitsPrograms/shaderProgram_" << std::setfill('0') << std::setw(2)
           << _shaderProgramIdx++ << ".txt";
  } else if (shaderType == PROGRAM_STRING) {
    if (format == GL_PROGRAM_FORMAT_ASCII_ARB) {
      stream << "gitsPrograms/program_";

      switch (target) {
      case GL_VERTEX_PROGRAM_ARB:
        stream << "vertex";
        break;
      case GL_FRAGMENT_PROGRAM_ARB:
        stream << "fragment";
        break;
      case GL_GEOMETRY_PROGRAM_NV:
        stream << "geometryNV";
        break;
      default:
        Log(ERR) << "Unknown target: " << target << " for '" << Name() << "'!!!";
        throw EOperationFailed(EXCEPTION_MESSAGE);
      }

      stream << "_ARB_" << std::setfill('0') << std::setw(2) << _programStringIdx++ << ".txt";
    } else {
      Log(ERR) << "Unknown target: 0x" << std::hex << target << " for " << Name() << "()!!!";
      throw EOperationFailed(EXCEPTION_MESSAGE);
    }
  }
  return stream.str();
}

std::string gits::OpenGL::CShaderSource::GetShaderSource(const GLchar* const* string,
                                                         GLsizei count,
                                                         const GLint* length) {
  std::string shaderSource;
  for (int i = 0; i < count; ++i) {
    if (length == nullptr || length[i] < 0) {
      shaderSource += std::string(string[i]);
    } else {
      shaderSource += std::string(string[i], string[i] + length[i]);
    }
    shaderSource += "\n";
  }
  return shaderSource;
}

std::string gits::OpenGL::CShaderSource::GetShaderSource(const GLchar* const* string,
                                                         GLsizei count) {
  std::string shaderSource;
  for (int i = 0; i < count; ++i) {
    shaderSource += std::string(string[i]);
    shaderSource += "\n";
  }
  return shaderSource;
}

gits::OpenGL::CShaderSource::CShaderSource(GLuint shaderObj,
                                           GLsizei count,
                                           const GLchar* const* string,
                                           const GLint* length,
                                           ShaderType shaderType)
    : CArgumentFileText(GetFileName(shaderType, 0, 0, shaderObj),
                        GetShaderSource(string, count, length)),
      text_cstr(nullptr) {}

gits::OpenGL::CShaderSource::CShaderSource(
    const GLchar* string, GLsizei length, ShaderType shaderType, GLenum target, GLenum format)
    : CArgumentFileText(GetFileName(shaderType, target, format, 0), std::string(string, length)),
      text_cstr(nullptr) {}

gits::OpenGL::CShaderSource::CShaderSource(GLsizei count,
                                           const GLchar* const* string,
                                           ShaderType shaderType)
    : CArgumentFileText(GetFileName(shaderType, 0, 0, 0), GetShaderSource(string, count)),
      text_cstr(nullptr) {}

const char** gits::OpenGL::CShaderSource::Value() {
  text_cstr = Text().c_str();
  return &text_cstr;
}

/* ************************************ I N T  Z E R O ********************************** */

const char* gits::OpenGL::CGLintptrZero::NAME = "GLintptrZero";

gits::OpenGL::CGLintptrZero::CGLintptrZero() {}

void gits::OpenGL::CGLintptrZero::Write(CCodeOStream& stream) const {
  std::ios_base::fmtflags streamFlags(stream.flags());
  stream << std::dec << 0;
  stream.flags(streamFlags);
}

uint64_t GetCArraySizeFromId(uint64_t id) {
  typedef std::map<uint64_t, uint64_t> map_t;
  INIT_NEW_STATIC_OBJ(idsMap, map_t);
  CALL_ONCE[&] {
    idsMap = gits::read_map<map_t>(gits::Config::Get().common.streamDir / "gitsClientSizes.dat");
  };
  if (idsMap.find(id) == idsMap.end()) {
    return 0;
  }
  return idsMap[id];
}

/* ********************************** CDataPtr ********************************* */
gits::OpenGL::CDataPtr::CDataPtr() : _ptr(0), _isBuff(false) {}

gits::OpenGL::CDataPtr::CDataPtr(const void* ptr) : _ptr((uint64_t)ptr), _isBuff(false) {}

gits::OpenGL::CDataPtr::CDataPtr(GLenum target, const void* ptr)
    : _ptr((uint64_t)ptr), _isBuff(false) {
  if (CGits::Instance().IsStateRestoration()) {
    throw std::runtime_error(EXCEPTION_MESSAGE);
  }
  GLint buffer;
  drv.gl.glGetIntegerv(GetBindingEnum(target), &buffer);
  if (buffer > 0) {
    *_isBuff = true;
  }
}

gits::OpenGL::CDataPtr::CDataPtr(GLint buffer, GLenum target, const void* ptr)
    : _ptr((uint64_t)ptr), _isBuff(false) {
  if (buffer < 0) {
    throw std::runtime_error(EXCEPTION_MESSAGE);
  }
  if (buffer > 0) {
    *_isBuff = true;
  }

  if (target == GL_DRAW_INDIRECT_BUFFER && !*_isBuff) {
    Log(ERR) << "Indirect client data not supported";
    throw ENotImplemented(EXCEPTION_MESSAGE);
  }
}

void gits::OpenGL::CDataPtr::Write(CBinOStream& stream) const {
  stream << _isBuff << _ptr;
}

void gits::OpenGL::CDataPtr::Read(CBinIStream& stream) {
  stream >> _isBuff;
  stream >> _ptr;
}

void gits::OpenGL::CDataPtr::Write(CCodeOStream& stream) const {
  std::ios_base::fmtflags streamFlags(stream.flags());
  if (*_isBuff != 0) {
    stream << std::hex << "(void*)" << *_ptr;
  } else {
    stream << "GetDataPtr(" << std::hex << _ptr << ")";
  }
  stream.flags(streamFlags);
}

void* gits::OpenGL::CDataPtr::Value() {
  if (!gits::Config::Get().IsPlayer()) {
    throw std::runtime_error(EXCEPTION_MESSAGE);
  }

  // Buffer offset
  if (*_isBuff != 0) {
    return (void*)*_ptr;
  }

  if (*_ptr == 0) {
    CALL_ONCE[&] {
      Log(WARN) << "passing invalid NULL pointer: " << std::hex << *_ptr << " to GL API.";
    };
    return (char*)*_ptr;
  }

  uint64_t areaOffset = GetAreaOffset(*_ptr);
  uint64_t areaRecPtr = GetAreaPtr(*_ptr);
  auto& memTracker = SD()._memTracker;

  // Alloc client data if needed
  if (memTracker.find(areaRecPtr) == memTracker.end()) {
    memTracker[areaRecPtr].resize((int)GetCArraySizeFromId(areaRecPtr), 0);
  }

  // Return client data ptr
  if (memTracker[areaRecPtr].size() <= areaOffset) {
    CALL_ONCE[&] {
      Log(WARN) << "passing invalid pointer: " << std::hex << *_ptr
                << " to GL API because it seems to not being used.";
    };
    return (char*)*_ptr;
  } else {
    char* ptr = &memTracker.at(areaRecPtr)[0] + areaOffset;
    return ptr;
  }
}

/* ********************************** CDataPtrArray ********************************* */
gits::OpenGL::CDataPtrArray::CDataPtrArray() : _isBuff(false) {}

gits::OpenGL::CDataPtrArray::CDataPtrArray(const void** ptrs, size_t size) : _isBuff(false) {
  for (unsigned i = 0; i < size; i++) {
    _ptrsRecorder.Vector().push_back((GLuint64)ptrs[i]);
  }
}

gits::OpenGL::CDataPtrArray::CDataPtrArray(GLenum target, const void* const* ptrs, size_t size)
    : _isBuff(false) {
  for (unsigned i = 0; i < size; i++) {
    _ptrsRecorder.Vector().push_back((GLuint64)ptrs[i]);
  }

  GLint buffer;
  drv.gl.glGetIntegerv(GetBindingEnum(target), &buffer);
  if (buffer > 0) {
    *_isBuff = true;
  }
}

gits::OpenGL::CDataPtrArray::CDataPtrArray(GLint buffer,
                                           GLenum target,
                                           const void** ptrs,
                                           size_t size)
    : _isBuff(false) {
  for (unsigned i = 0; i < size; i++) {
    _ptrsRecorder.Vector().push_back((GLuint64)ptrs[i]);
  }

  if (buffer == -1) {
    drv.gl.glGetIntegerv(GetBindingEnum(target), &buffer);
  }
  if (buffer > 0) {
    *_isBuff = true;
  }
}

void gits::OpenGL::CDataPtrArray::Write(CBinOStream& stream) const {
  stream << _isBuff << _ptrsRecorder;
}
void gits::OpenGL::CDataPtrArray::Read(CBinIStream& stream) {
  stream >> _isBuff;
  stream >> _ptrsRecorder;
}
void gits::OpenGL::CDataPtrArray::Write(CCodeOStream& stream) const {
  stream << "&" << stream.VariableName(ScopeKey()) << "[0]";
}
void gits::OpenGL::CDataPtrArray::Declare(CCodeOStream& stream) const {
  stream.Indent() << Name() << "const void* " << stream.VariableName(ScopeKey()) << "[] = ";
  // declare an array
  stream << "{ ";

  // initiate all elements in an array
  if (_ptrsRecorder.Vector().size() == 0) {
    stream << "0";
  } else {
    size_t idx = 0;
    size_t size = _ptrsRecorder.Vector().size();
    for (auto ptr : _ptrsRecorder.Vector()) {
      // Buffer offset
      if (*_isBuff != 0) {
        if (ptr != (uintptr_t)ptr) {
          throw std::runtime_error(EXCEPTION_MESSAGE);
        }
        stream << "(void*)" << ptr;
      } else {
        uint64_t areaOffset = GetAreaOffset(ptr);
        uint64_t areaRecPtr = GetAreaPtr(ptr);
        auto& memTracker = SD()._memTracker;

        // Alloc client data if needed
        if (memTracker.find(areaRecPtr) == memTracker.end()) {
          memTracker[areaRecPtr].resize((int)GetCArraySizeFromId(areaRecPtr), 0);
        }

        // Return client data ptr
        if (memTracker[areaRecPtr].size() <= areaOffset) {
          CALL_ONCE[&] {
            Log(WARN) << "passing invalid pointer: " << std::hex << areaRecPtr
                      << " to GL API because it seems to not being used.";
          };
          stream << "(void*)" << areaRecPtr;
        } else {
          stream << "(void*)" << (&memTracker.at(areaRecPtr)[0] + areaOffset);
        }
      }
      if (++idx < size) {
        stream << ", ";
      }
    }
  }
  stream << " };\n";
}

const void** gits::OpenGL::CDataPtrArray::Value() {
  if (!gits::Config::Get().IsPlayer()) {
    throw std::runtime_error(EXCEPTION_MESSAGE);
  }

  if (_ptrsPlayer.size() == 0) {
    for (auto ptr : _ptrsRecorder.Vector()) {
      // Buffer offset
      if (*_isBuff != 0) {
        if (ptr != (uintptr_t)ptr) {
          throw std::runtime_error(EXCEPTION_MESSAGE);
        }
        _ptrsPlayer.push_back((void*)ptr);
        continue;
      }

      uint64_t areaOffset = GetAreaOffset(ptr);
      uint64_t areaRecPtr = GetAreaPtr(ptr);
      auto& memTracker = SD()._memTracker;

      // Alloc client data if needed
      if (memTracker.find(areaRecPtr) == memTracker.end()) {
        memTracker[areaRecPtr].resize((int)GetCArraySizeFromId(areaRecPtr), 0);
      }

      // Return client data ptr
      if (memTracker[areaRecPtr].size() <= areaOffset) {
        CALL_ONCE[&] {
          Log(WARN) << "passing invalid pointer: " << std::hex << areaRecPtr
                    << " to GL API because it seems to not being used.";
        };
        _ptrsPlayer.push_back((void*)areaRecPtr);
      } else {
        _ptrsPlayer.push_back((void*)(&memTracker.at(areaRecPtr)[0] + areaOffset));
      }
    }
  }

  return &_ptrsPlayer[0];
}

/* ******************************** CDataUpdate **************************** */

// Select diff method.
void gits::OpenGL::CDataUpdate::Diff(uint64_t dataptr, uint64_t updateptr, uint64_t updatesize) {
  if (Config::Get().recorder.openGL.utilities.carrayMemCmpType == 0) {
    DiffAll(dataptr, updateptr, updatesize);
  } else if (Config::Get().recorder.openGL.utilities.carrayMemCmpType == 1) {
    DiffOneRange(dataptr, updateptr, updatesize);
  } else if (Config::Get().recorder.openGL.utilities.carrayMemCmpType == 2) {
    DiffMultiRange(dataptr, updateptr, updatesize);
  } else {
    throw ENotImplemented(EXCEPTION_MESSAGE);
  }
}

// Do not compare any data, simply create diff from entire pointed data.
void gits::OpenGL::CDataUpdate::DiffAll(uint64_t dataptr, uint64_t updateptr, uint64_t updatesize) {
  uint64_t areaPtr = GetAreaPtr(dataptr);
  uint64_t areaOffset = GetAreaOffset(dataptr);
  uint64_t updateOffset = areaOffset + (updateptr - dataptr);
  uint64_t totalSize = (updateptr - areaPtr) + updatesize;
  auto& memTracker = SD()._memTracker;

  // Extend tracked memory area.
  if (memTracker[areaPtr].size() < totalSize) {
    memTracker[areaPtr].resize((size_t)(totalSize), 0);
  }

  // Dump entire update data.
  uint64_t hash = CGits::Instance().ResourceManager().put(RESOURCE_BUFFER, (void*)updateptr,
                                                          (size_t)updatesize);
  _updates.push_back(TData(areaPtr, hash, updateOffset));

  if (Config::Get().recorder.extras.utilities.highIntegrity) {
    SD().WriteClientSizes();
  }
}

// Compares data and creates one diff starting at first different byte and
// ending at last different byte.
void gits::OpenGL::CDataUpdate::DiffOneRange(uint64_t dataptr,
                                             uint64_t updateptr,
                                             uint64_t updatesize) {
  uint64_t areaPtr = GetAreaPtr(dataptr);
  uint64_t areaOffset = GetAreaOffset(dataptr);
  uint64_t updateOffset = areaOffset + (updateptr - dataptr);
  uint64_t totalSize = (updateptr - areaPtr) + updatesize;

  // Extend tracked memory area.
  auto& memTracker = SD()._memTracker;
  if (memTracker[areaPtr].size() < totalSize) {
    memTracker[areaPtr].resize((size_t)(totalSize), 0);
  }

  char* updateBegin = (char*)updateptr;
  char* updateEnd = updateBegin + updatesize;
  char* storeUpdateBegin = &memTracker[areaPtr][0] + updateOffset;
  char* storeUpdateEnd = &memTracker[areaPtr][0] + updateOffset + updatesize;
  char* diffBegin = updateBegin;
  char* diffEnd = updateEnd;
  char* storeDiffBegin = storeUpdateBegin;

  char* dataPtr;
  char* storeDataPtr;

  // Find diff begin.
  for (dataPtr = updateBegin, storeDataPtr = storeUpdateBegin; dataPtr < updateEnd;
       dataPtr++, storeDataPtr++) {
    if (*dataPtr != *storeDataPtr) {
      break;
    }
  }
  diffBegin = dataPtr;
  storeDiffBegin = storeDataPtr;

  // Find diff end.
  if (diffBegin != updateEnd) {
    char* updateBack = --updateEnd;
    char* updateDataBack = --storeUpdateEnd;
    for (dataPtr = updateBack, storeDataPtr = updateDataBack; dataPtr >= diffBegin;
         dataPtr--, storeDataPtr--) {
      if (*dataPtr != *storeDataPtr) {
        break;
      }
    }
    diffEnd = ++dataPtr;
  }

  if (diffBegin != diffEnd) {
    unsigned diffSize = (unsigned)(diffEnd - diffBegin);
    // Dump diff
    uint64_t hash = CGits::Instance().ResourceManager().put(RESOURCE_BUFFER, diffBegin, diffSize);
    uint64_t diffOffset = (uint64_t)diffBegin - (uint64_t)areaPtr;
    _updates.push_back(TData(areaPtr, hash, diffOffset));

    // Update stored memory area
    memcpy(storeDiffBegin, diffBegin, diffSize);
  }

  if (Config::Get().recorder.extras.utilities.highIntegrity) {
    SD().WriteClientSizes();
  }
}

// Compares data blocks of specified size and dumps as many diffs as different blocks.
void gits::OpenGL::CDataUpdate::DiffMultiRange(uint64_t dataptr,
                                               uint64_t updateptr,
                                               uint64_t updatesize) {
  uint64_t areaPtr = GetAreaPtr(dataptr);
  uint64_t updateOffset = updateptr - areaPtr;
  uint64_t totalSize = updateOffset + updatesize;

  // Extend tracked memory area.
  auto& memTracker = SD()._memTracker;
  if (memTracker[areaPtr].size() < totalSize) {
    memTracker[areaPtr].resize((size_t)(totalSize), 0);
  }

  // Get diff area.
  char* updateBegin = (char*)updateptr;
  char* updateEnd = updateBegin + updatesize;
  char* storeUpdateBegin = &memTracker[areaPtr][0] + updateOffset;
  char* diffBegin = updateBegin;
  char* diffEnd = updateEnd;
  char* storeDiffBegin = storeUpdateBegin;

  char* dataPtr;
  char* storeDataPtr;

  //**Lambda - Store diff
  auto StoreDiff = [&]() {
    if (diffBegin != diffEnd) {
      unsigned diffSize = (unsigned)(diffEnd - diffBegin);
      // Dump diff.
      uint64_t hash = CGits::Instance().ResourceManager().put(RESOURCE_BUFFER, diffBegin, diffSize);
      uint64_t diffOffset = (uint64_t)diffBegin - (uint64_t)areaPtr;
      _updates.push_back(TData(areaPtr, hash, diffOffset));

      // Update stored memory area.
      memcpy(storeDiffBegin, diffBegin, diffSize);
    }
  };

  // Find and dump diffs.
  unsigned cmpBlockSize = 32;
  dataPtr = updateBegin;
  storeDataPtr = storeUpdateBegin;
  auto updateBack = updateEnd - cmpBlockSize;
  while (dataPtr <= updateBack) {
    // find diff
    if (memcmp(dataPtr, storeDataPtr, cmpBlockSize) != 0) {
      // get diff size
      diffBegin = dataPtr;
      storeDiffBegin = storeDataPtr;

      while (dataPtr <= updateBack && memcmp(dataPtr, storeDataPtr, cmpBlockSize) != 0) {
        dataPtr += cmpBlockSize;
        storeDataPtr += cmpBlockSize;
      }
      unsigned ending = (unsigned)(updateEnd - dataPtr);
      if (ending < cmpBlockSize) { // ending fix up
        dataPtr = updateEnd;
      }
      diffEnd = dataPtr;
      StoreDiff();
    } else {
      dataPtr += cmpBlockSize;
      storeDataPtr += cmpBlockSize;
    }
  }
  if (dataPtr < updateEnd) {
    diffBegin = dataPtr;
    storeDiffBegin = storeDataPtr;
    diffEnd = updateEnd;
    if (memcmp(diffBegin, storeDiffBegin, (unsigned)(diffEnd - diffBegin)) != 0) {
      StoreDiff();
    }
  }

  if (Config::Get().recorder.extras.utilities.highIntegrity) {
    SD().WriteClientSizes();
  }
}

void gits::OpenGL::CDataUpdate::Apply() {
  for (auto& updateRef : _updates) {
    uint64_t areaPtrRec = updateRef.area;
    uint64_t updateOffset = updateRef.offset;
    auto& memTracker = SD()._memTracker;

    // Allocate memory if needed.
    if (memTracker.find(areaPtrRec) == memTracker.end()) {
      memTracker[areaPtrRec].resize((size_t)GetCArraySizeFromId(areaPtrRec), 0);
    }

    // Apply diff.
    char* dataPtr = &memTracker[areaPtrRec][0] + updateOffset;
    memcpy(dataPtr, &updateRef.playerCache[0], updateRef.playerCache.size());
  }
}

void gits::OpenGL::CDataUpdate::Write(CBinOStream& stream) const {
  stream << CGLuint((unsigned)_updates.size());
  for (auto& update : _updates) {
    stream << CGLuint64(update.area);
    stream << CGLuint64(update.hash);
    stream << CGLuint64(update.offset);
  }
}

void gits::OpenGL::CDataUpdate::Read(CBinIStream& stream) {
  CGLuint size;
  CGLuint64 area;
  CGLuint64 hash;
  CGLuint64 offset;
  stream >> size;
  for (uint32_t i = 0; i < *size; i++) {
    _updates.push_back(TData());
    stream >> area;
    _updates.back().area = *area;
    stream >> hash;
    _updates.back().hash = *hash;
    stream >> offset;
    _updates.back().offset = *offset;

    // Cache
    CBinaryResource::PointerProxy ptrProxy = CBinaryResource::PointerProxy(
        gits::CGits::Instance().ResourceManager().get(_updates.back().hash));
    const char* updatePtr = (const char*)ptrProxy;
    const size_t size_ = gits::CGits::Instance().ResourceManager().get(_updates.back().hash).size();
    _updates.back().playerCache.resize(size_);
    memcpy(&_updates.back().playerCache[0], updatePtr, size_);
  }
}

void gits::OpenGL::CDataUpdate::Write(CCodeOStream& stream) const {
  std::ios_base::fmtflags streamFlags(stream.flags());
  for (auto& i : _updates) {
    stream.Indent() << "DataUpdate(" << std::hex << i.area << ", " << std::dec << i.offset << ", "
                    << std::hex << i.hash << ");\n";
  }
  stream.flags(streamFlags);
}

//************************************** CCoherentBufferUpdate ********************************************************

std::unordered_map<GLuint, GLenum> gits::OpenGL::CCoherentBufferUpdate::GetCurrentBuffers(
    TCoherentBufferData::UpdateType updateType, bool oncePerFrame) {
  if (oncePerFrame == true && (SD().GetCurrentSharedStateData().coherentBufferFrameNumber !=
                               CGits::Instance().CurrentFrame())) {
    SD().GetCurrentSharedStateData().coherentBufferUpdatedSet.clear();
    SD().GetCurrentSharedStateData().coherentBufferFrameNumber = CGits::Instance().CurrentFrame();
  }
  std::unordered_map<GLuint, GLenum> buffers;
  GLint attribs = 0;
  auto insert_buffer = [&](GLint buffer, GLenum target) {
    if ((oncePerFrame == false) ||
        (SD().GetCurrentSharedStateData().coherentBufferUpdatedSet.find(buffer) ==
         SD().GetCurrentSharedStateData().coherentBufferUpdatedSet.end())) {
      buffers.insert(std::pair<GLuint, GLenum>((GLuint)buffer, target));
      if (oncePerFrame == true) {
        SD().GetCurrentSharedStateData().coherentBufferUpdatedSet.insert(buffer);
      }
    }
  };
  auto add_buffer = [&](GLenum binding_target, GLenum target) {
    GLint buf = 0;
    drv.gl.glGetIntegerv(binding_target, &buf);
    if (buf != 0) {
      insert_buffer(buf, target);
    }
  };

  if (updateType == TCoherentBufferData::PER_DRAWCALL_UPDATE ||
      updateType == TCoherentBufferData::PER_FRAME_UPDATE) {
    auto can_query_vertex_attribs = [&]() {
      bool isVaoMandatory = curctx::IsEs2Plus() || (curctx::IsOgl() && SD().IsCurrentContextCore());
      GLint vao = 0;
      drv.gl.glGetIntegerv(GL_VERTEX_ARRAY_BINDING, &vao);
      return !isVaoMandatory || vao != 0;
    };

    if (can_query_vertex_attribs()) {
      drv.gl.glGetIntegerv(GL_MAX_VERTEX_ATTRIBS, &attribs);

      for (int i = 0; i < attribs; ++i) {
        GLint enabled = GL_FALSE;
        drv.gl.glGetVertexAttribiv(i, GL_VERTEX_ATTRIB_ARRAY_ENABLED, &enabled);
        if (enabled == GL_TRUE) {
          GLint buf = 0;
          drv.gl.glGetVertexAttribiv(i, GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, &buf);
          insert_buffer(buf, GL_ARRAY_BUFFER);
        }
      }
      add_buffer(GL_ELEMENT_ARRAY_BUFFER_BINDING, GL_ELEMENT_ARRAY_BUFFER);
      auto& indexedTargets =
          SD().GetCurrentSharedStateData().IndexedBoundBuffers().TargetsInfo()[GL_UNIFORM_BUFFER];
      for (const auto& uniformBuff : indexedTargets) {
        if (uniformBuff.second.buffer != 0) {
          insert_buffer(uniformBuff.second.buffer, GL_UNIFORM_BUFFER);
        }
      }
    }
    GLint texUnit;
    GLint maxTexUnits;
    GLint tex_buffer_boundtex;
    GLuint texbuffer_buffer = 0;
    drv.gl.glGetIntegerv(GL_ACTIVE_TEXTURE, &texUnit);
    drv.gl.glGetIntegerv(GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS, &maxTexUnits);

    for (int unit = GL_TEXTURE0; unit < GL_TEXTURE0 + maxTexUnits; unit++) {
      drv.gl.glActiveTexture(unit);
      drv.gl.glGetIntegerv(GL_TEXTURE_BINDING_BUFFER_EXT, &tex_buffer_boundtex);
      CTextureStateObj* tex = SD().GetCurrentSharedStateData().Textures().Get(
          CTextureStateObj(tex_buffer_boundtex, GL_TEXTURE_BUFFER));
      if (tex != nullptr) {
        texbuffer_buffer = tex->Data().track.texbuffer_buffer;
      }
      if (texbuffer_buffer > 0) {
        insert_buffer(texbuffer_buffer, GL_TEXTURE_BUFFER_EXT);
      }
      texbuffer_buffer = 0;
    }
    drv.gl.glActiveTexture(texUnit);

    if ((curctx::IsOgl() && curctx::Version() >= 430) || curctx::IsEs31Plus()) {
      GLint shaderStorageBuffer;
      drv.gl.glGetIntegerv(GL_SHADER_STORAGE_BUFFER_BINDING, &shaderStorageBuffer);
      insert_buffer(shaderStorageBuffer, GL_SHADER_STORAGE_BUFFER);

      GLint maxShaderStorageBindings;
      drv.gl.glGetIntegerv(GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS, &maxShaderStorageBindings);
      for (int i = 0; i < maxShaderStorageBindings; i++) {
        drv.gl.glGetIntegeri_v(GL_SHADER_STORAGE_BUFFER_BINDING, i, &shaderStorageBuffer);
        insert_buffer(shaderStorageBuffer, GL_SHADER_STORAGE_BUFFER);
      }
    }
  }

  if (curctx::IsOgl() && updateType == TCoherentBufferData::TEXTURE_UPDATE) {
    add_buffer(GL_PIXEL_UNPACK_BUFFER_BINDING, GL_PIXEL_UNPACK_BUFFER);
  }

  buffers.erase(0);
  return buffers;
}

void gits::OpenGL::CCoherentBufferUpdate::Diff(TCoherentBufferData::UpdateType updateType,
                                               TCoherentBufferData::UpdateMode updateMode,
                                               bool oncePerFrame) {

  GLint tex_buffer_bound;
  GLint array_buffer_bound;
  GLint shader_storage_buffer_bound = 0;
  drv.gl.glGetIntegerv(GL_TEXTURE_BUFFER_BINDING, &tex_buffer_bound);
  drv.gl.glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &array_buffer_bound);
  if ((curctx::IsOgl() && curctx::Version() >= 430) || curctx::IsEs31Plus()) {
    drv.gl.glGetIntegerv(GL_SHADER_STORAGE_BUFFER_BINDING, &shader_storage_buffer_bound);
  }

  for (const auto& buff : GetCurrentBuffers(updateType, oncePerFrame)) {
    GLuint buffer = buff.first;
    GLenum target = buff.second;
    GLint size = 0;
    auto& mapping = SD().GetCurrentSharedStateData().Buffers().Get(buffer)->Data().restore;
    GLint access = mapping.mapAccess;
    GLint length = mapping.mapLength;
    GLint offset = mapping.mapOffset;
    bool named_buffer = mapping.named;
    CBufferStateData::Restored::buffer_type type = mapping.type;

    if (mapping.mapped &&
        SD().GetCurrentSharedStateData().Buffers().Get(buffer)->Data().track.coherentMapping) {
      if (!named_buffer) {
        drv.gl.glBindBuffer(target, buffer);
      }
      auto func_map = _glMapBuffer_wrap;
      auto func_unmap = _glUnmapBuffer_wrap;
      auto func_get = _glGetBufferParameteriv_wrap;

      if (named_buffer == false) {
        if (type == CBufferStateData::Restored::MAP_BUFFER_ARB) {
          func_map = _glMapBufferARB_wrap;
          func_unmap = _glUnmapBufferARB_wrap;
        } else if (type == CBufferStateData::Restored::MAP_BUFFER_OES) {
          func_map = _glMapBufferOES_wrap;
          func_unmap = _glUnmapBufferOES_wrap;
        }
      } else {
        if (type == CBufferStateData::Restored::MAP_BUFFER_EXT) {
          func_map = _glMapNamedBufferEXT_wrap;
          func_unmap = _glUnmapNamedBufferEXT_wrap;
          func_get = _glGetNamedBufferParameterivEXT_wrap;
        }
      }

      GLvoid* pointer = nullptr;
      if (length == -1 && offset == -1) {
        if (!(access & GL_MAP_READ_BIT)) {
          // Unmapping after glMapBuffer
          auto access_type = GL_READ_ONLY;
          // buffer is remapped with write permissions again, as we can read
          // write-only mapping - read it, and save
          if ((curctx::IsEs1() || curctx::IsEs2Plus()) &&
              ESBufferState() != TBuffersState::BUFFERS_STATE_CAPTURE_ALWAYS) {
            access_type = GL_WRITE_ONLY;
          } else { // buffer is remapped with read permissions now - read it,
                   // and save
            access_type = GL_READ_ONLY;
          }

          func_unmap(buffer, target);
          func_get(buffer, target, GL_BUFFER_SIZE, &size);
          pointer = func_map(buffer, target, access_type);
        }
      } else {
        if (!(access & GL_MAP_READ_BIT)) {
          // Unmapping after glMapBufferRange
          // here buffer is remapped with read permissions now - read it, and
          // save
          func_unmap(buffer, target);
          if (named_buffer == false) {
            pointer = drv.gl.glMapBufferRange(target, offset, length, GL_MAP_READ_BIT);
          } else {
            pointer = drv.gl.glMapNamedBufferRangeEXT(buffer, offset, length, GL_MAP_READ_BIT);
          }
        }
      }
      if (pointer == nullptr) {
        auto func_get_buffer_pointer = _glGetBufferPointerv_wrap;
        if (named_buffer == false) {
          if (type == CBufferStateData::Restored::MAP_BUFFER_ARB) {
            func_get_buffer_pointer = _glGetBufferPointervARB_wrap;
          } else if (type == CBufferStateData::Restored::MAP_BUFFER_OES) {
            func_get_buffer_pointer = _glGetBufferPointervOES_wrap;
          }
        } else {
          if (type == CBufferStateData::Restored::MAP_BUFFER_EXT) {
            func_get_buffer_pointer = _glGetNamedBufferPointervEXT_wrap;
          }
        }

        func_get_buffer_pointer(buffer, target, GL_BUFFER_MAP_POINTER, &pointer);
      }

      // Populate _resource if data was changed.
      if (pointer != nullptr) {
        auto* bufferDataPtr = SD().GetCurrentSharedStateData().Buffers().Get(buffer);
        if (bufferDataPtr == nullptr) {
          throw std::runtime_error(EXCEPTION_MESSAGE);
        }

        // Optimized size of mapped buffer data dump
        if (Config::Get().recorder.openGL.utilities.optimizeBufferSize) {
          // Access to mapped memory is multiple times slower than access to cpu
          // memory so it is better to read it only once. Though temporary copy
          // of mapped memory is created there.
          auto mapMemSrc = pointer;
          GLsizeiptr tmpMapMemCpySize = 0;
          if (bufferDataPtr->Data().restore.mapLength == -1) {
            tmpMapMemCpySize = bufferDataPtr->Data().track.size;
          } else {
            tmpMapMemCpySize = bufferDataPtr->Data().restore.mapLength;
          }
          void* tmpMapMemCpy = malloc(tmpMapMemCpySize);
          void* tmpMapMemCpyDst = tmpMapMemCpy;
          // If map range flushing is used only flushed part of memory is being
          // copied to improve recorder performance
          if (bufferDataPtr->Data().restore.mapFlushRangeLength > 0) {
            mapMemSrc = (char*)mapMemSrc + bufferDataPtr->Data().restore.mapFlushRangeOffset;
            tmpMapMemCpyDst =
                (char*)tmpMapMemCpy + bufferDataPtr->Data().restore.mapFlushRangeOffset;
            tmpMapMemCpySize = bufferDataPtr->Data().restore.mapFlushRangeLength;
          }
          memcpy(tmpMapMemCpyDst, mapMemSrc, tmpMapMemCpySize);

          GLintptr mapOffset = 0;
          GLintptr buffOffset = 0;
          GLsizeiptr mapSize = 0;
          bufferDataPtr->CalculateMapChange(mapOffset, buffOffset, mapSize, tmpMapMemCpy);
          bufferDataPtr->TrackBufferData(buffOffset, mapSize, (char*)tmpMapMemCpy + mapOffset);
          offset = (int)mapOffset;
          length = (int)mapSize;
          if (mapSize != 0) {
            uint64_t hash = CGits::Instance().ResourceManager().put(
                RESOURCE_BUFFER, ((GLubyte*)tmpMapMemCpy) + mapOffset, mapSize);
            _updates.push_back(TCoherentBufferData(hash, offset, buffer, length, target));
          }
          free(tmpMapMemCpy);
        }
        // Entire mapped buffer data dump
        else {
          if (bufferDataPtr->Data().restore.mapLength == -1) {
            length = bufferDataPtr->Data().track.size;
          } else {
            length = bufferDataPtr->Data().restore.mapLength;
          }

          offset = 0;
          if (length != 0) {
            uint64_t hash = CGits::Instance().ResourceManager().put(RESOURCE_BUFFER,
                                                                    ((GLubyte*)pointer), length);
            _updates.push_back(TCoherentBufferData(hash, offset, buffer, length, target));
          }
        }
      }
    }
  }
  drv.gl.glBindBuffer(GL_TEXTURE_BUFFER_EXT, tex_buffer_bound);
  drv.gl.glBindBuffer(GL_ARRAY_BUFFER, array_buffer_bound);
  if ((curctx::IsOgl() && curctx::Version() >= 430) || curctx::IsEs31Plus()) {
    drv.gl.glBindBuffer(GL_SHADER_STORAGE_BUFFER, shader_storage_buffer_bound);
  }
}

void gits::OpenGL::CCoherentBufferUpdate::Apply() {

  GLint tex_buffer_bound;
  GLint array_buffer_bound;
  GLint shader_storage_buffer_bound = 0;
  drv.gl.glGetIntegerv(GL_TEXTURE_BUFFER_BINDING, &tex_buffer_bound);
  drv.gl.glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &array_buffer_bound);
  if ((curctx::IsOgl() && curctx::Version() >= 430) || curctx::IsEs31Plus()) {
    drv.gl.glGetIntegerv(GL_SHADER_STORAGE_BUFFER_BINDING, &shader_storage_buffer_bound);
  }

  for (auto& updateRef : _updates) {
    GLvoid* pointer;
    GLuint recBuff = updateRef._buffer_name;

    GLuint playBuff;
    GLenum target = updateRef._target;
    GLuint offset = updateRef._offset;

    playBuff = CGLBuffer::GetMapping(recBuff);
    auto func_get_buffer_pointer = _glGetBufferPointerv_wrap;
    auto& restoredData = SD().GetCurrentSharedStateData().Buffers().Get(playBuff)->Data().restore;
    if (restoredData.named == false) {
      drv.gl.glBindBuffer(target, playBuff);
      if (restoredData.type == CBufferStateData::Restored::MAP_BUFFER_ARB) {
        func_get_buffer_pointer = _glGetBufferPointervARB_wrap;
      } else if (restoredData.type == CBufferStateData::Restored::MAP_BUFFER_OES) {
        func_get_buffer_pointer = _glGetBufferPointervOES_wrap;
      }
    } else {
      if (restoredData.type == CBufferStateData::Restored::MAP_BUFFER_EXT) {
        func_get_buffer_pointer = _glGetNamedBufferPointervEXT_wrap;
      }
    }

    func_get_buffer_pointer(playBuff, target, GL_BUFFER_MAP_POINTER, &pointer);

    if (playBuff == 0) {
      throw EOperationFailed((std::string)EXCEPTION_MESSAGE + " unmapping buffer zero");
    } else if (SD().GetCurrentSharedStateData().Buffers().Get(playBuff) == nullptr) {
      throw EOperationFailed((std::string)EXCEPTION_MESSAGE + " unknown buffer object");
    }
    if (!SD().GetCurrentSharedStateData().Buffers().Get(playBuff)->Data().restore.mapped) {
      Log(WARN) << "Unmapping unmapped buffer";
    } else {
      std::memcpy(((GLubyte*)pointer) + offset, &updateRef.playerCache[0],
                  updateRef.playerCache.size());
      updateRef.playerCache.clear();
    }
  }
  drv.gl.glBindBuffer(GL_TEXTURE_BUFFER_EXT, tex_buffer_bound);
  drv.gl.glBindBuffer(GL_ARRAY_BUFFER, array_buffer_bound);
  if ((curctx::IsOgl() && curctx::Version() >= 430) || curctx::IsEs31Plus()) {
    drv.gl.glBindBuffer(GL_SHADER_STORAGE_BUFFER, shader_storage_buffer_bound);
  }
}

void gits::OpenGL::CCoherentBufferUpdate::Write(CBinOStream& stream) const {
  stream << CGLuint((unsigned)_updates.size());
  for (auto& update : _updates) {
    stream << CGLuint64(update._hash);
    stream << CGLuint(update._offset);
    stream << CGLuint(update._buffer_name);
    stream << CGLuint(update._length);
    stream << CGLuint(update._target);
  }
}

void gits::OpenGL::CCoherentBufferUpdate::Read(CBinIStream& stream) {
  CGLuint size;
  CGLuint64 hash;
  CGLuint offset;
  CGLuint buffer_name;
  CGLuint length;
  CGLuint target;
  stream >> size;
  for (uint32_t i = 0; i < *size; i++) {
    _updates.push_back(TCoherentBufferData());
    stream >> hash;
    _updates.back()._hash = *hash;
    stream >> offset;
    _updates.back()._offset = *offset;
    stream >> buffer_name;
    _updates.back()._buffer_name = *buffer_name;
    stream >> length;
    _updates.back()._length = *length;
    stream >> target;
    _updates.back()._target = *target;

    // Cache
    CBinaryResource::PointerProxy ptrProxy = CBinaryResource::PointerProxy(
        gits::CGits::Instance().ResourceManager().get(_updates.back()._hash));
    const char* updatePtr = (const char*)ptrProxy;
    const size_t size_ =
        gits::CGits::Instance().ResourceManager().get(_updates.back()._hash).size();
    _updates.back().playerCache.resize(size_);
    memcpy(&_updates.back().playerCache[0], updatePtr, size_);
  }
}

/* ******************************** CGLSamplerType****************************** */
const char* gits::OpenGL::CGLSamplerType::NAME = "GLuint";

void gits::OpenGL::CGLSamplerType::Write(CCodeOStream& stream) const {
  std::ios_base::fmtflags streamFlags(stream.flags());
  stream << std::dec << Value();
  stream.flags(streamFlags);
}

/* ********************************* G L C L A M P X ******************************* */

const char* gits::OpenGL::CGLclampx::NAME = "GLclampx";

gits::OpenGL::CGLclampx::CGLclampx() : CGLtype<GLtype, type>() {}

gits::OpenGL::CGLclampx::CGLclampx(GLclampx value) : CGLtype<GLtype, type>(value) {}

void gits::OpenGL::CGLclampx::Write(CCodeOStream& stream) const {
  std::ios_base::fmtflags streamFlags(stream.flags());
  stream << std::showpoint << Value();
  stream.flags(streamFlags);
}

/* ********************************* G L F I X E D ******************************* */

const char* gits::OpenGL::CGLfixed::NAME = "GLfixed";

gits::OpenGL::CGLfixed::CGLfixed() : CGLtype<GLtype, type>() {}

gits::OpenGL::CGLfixed::CGLfixed(GLfixed value) : CGLtype<GLtype, type>(value) {}

void gits::OpenGL::CGLfixed::Write(CCodeOStream& stream) const {
  std::ios_base::fmtflags streamFlags(stream.flags());
  stream << std::showpoint << Value();
  stream.flags(streamFlags);
}

/* ******************************** CGLsyncType ****************************** */
const char* gits::OpenGL::CGLsyncType::NAME = "GLsync";
gits::OpenGL::CGLsyncType::CGLsyncType() {}

gits::OpenGL::CGLsyncType::CGLsyncType(GLsync value) : CGLtype<GLtype, type>(value) {}

void gits::OpenGL::CGLsyncType::Write(CCodeOStream& stream) const {
  std::ios_base::fmtflags streamFlags(stream.flags());
  stream << "(GLsync)" << std::hex << static_cast<const void*>(Original());
  stream.flags(streamFlags);
}

/*****************************************************************************/

gits::OpenGL::CGLIndirectCmds::CGLIndirectCmds() : ptr_value_(0), count_(0), buffer_(0) {}

gits::OpenGL::CGLIndirectCmds::CGLIndirectCmds(const void* ptr, uint32_t count) : count_(count) {
  drv.gl.glGetIntegerv(GL_DRAW_INDIRECT_BUFFER_BINDING, &buffer_);
  if (buffer_ == 0) {
    const DrawArraysIndirectCommand* cmd_ptr = (DrawArraysIndirectCommand*)ptr;
    cmds_.assign(cmd_ptr, cmd_ptr + count);
  }
  ptr_value_ = reinterpret_cast<uintptr_t>(ptr);
}

const void* gits::OpenGL::CGLIndirectCmds::operator*() {
  if (buffer_ == 0) {
    return &cmds_[0];
  }
  return reinterpret_cast<const void*>(static_cast<uintptr_t>(ptr_value_));
}

void gits::OpenGL::CGLIndirectCmds::Write(CBinOStream& stream) const {
  write_to_stream(stream, ptr_value_);
  write_to_stream(stream, count_);
  write_to_stream(stream, buffer_);
  if (buffer_ == 0) {
    for (uint32_t i = 0; i < count_; ++i) {
      write_to_stream(stream, cmds_[i]);
    }
  }
}

void gits::OpenGL::CGLIndirectCmds::Read(CBinIStream& stream) {
  read_from_stream(stream, ptr_value_);
  read_from_stream(stream, count_);
  read_from_stream(stream, buffer_);
  if (buffer_ == 0) {
    if (count_ <= cmds_.max_size()) {
      cmds_.resize(count_);
      for (uint32_t i = 0; i < count_; ++i) {
        read_from_stream(stream, cmds_[i]);
      }
    } else {
      throw std::runtime_error(EXCEPTION_MESSAGE);
    }
  }
}

void gits::OpenGL::CGLIndirectCmds::Write(CCodeOStream& stream) const {
  stream << "/*indirect command not supported in ccode*/";
}

gits::OpenGL::CGLGenericResource::CGLGenericResource(const GLvoid* ptr,
                                                     size_t size,
                                                     GLenum sourceTarget,
                                                     TResourceType resourceType) {
  // Get currently bound source buffer
  if (CGits::Instance().IsStateRestoration()) {
    throw std::runtime_error(EXCEPTION_MESSAGE);
  }

  GLuint buffer = 0;
  if (sourceTarget != 0) {
    drv.gl.glGetIntegerv(GetBindingEnum(sourceTarget), (GLint*)&buffer);
  }

  *_isBuff = buffer != 0;
  if (buffer == 0) {
    _resource.reset(resourceType, ptr, size);
  } else {
    *_buffOffset = (GLuint64)ptr;
  }
}

gits::CBinaryResource::PointerProxy gits::OpenGL::CGLGenericResource::Value() {
  if (*_isBuff == 0) {
    return _resource.Data();
  } else {
    return CBinaryResource::PointerProxy((void*)*_buffOffset);
  }
}

gits::CBinaryResource::PointerProxy gits::OpenGL::CGLGenericResource::operator*() {
  return Value();
}

void gits::OpenGL::CGLGenericResource::Write(CBinOStream& stream) const {
  stream << _isBuff;
  if (*_isBuff == 0) {
    stream << _resource;
  } else {
    stream << _buffOffset;
  }
}

void gits::OpenGL::CGLGenericResource::Read(CBinIStream& stream) {
  stream >> _isBuff;
  if (*_isBuff == 0) {
    stream >> _resource;
  } else {
    stream >> _buffOffset;
  }
}

void gits::OpenGL::CGLGenericResource::Write(CCodeOStream& stream) const {
  std::ios_base::fmtflags streamFlags(stream.flags());
  if (*_isBuff == 0) {
    stream << "Resource(" << _resource.GetResourceHash() << ")";
  } else {
    stream << "(void*)" << std::hex << _buffOffset;
  }
  stream.flags(streamFlags);
}

gits::OpenGL::CGLTexResource::CGLTexResource(
    GLenum target, GLenum format, GLenum type, GLsizei width, const GLvoid* ptr)
    : _resource(
          ptr, TexDataSize(format, type, width, 1, 1), GL_PIXEL_UNPACK_BUFFER, RESOURCE_TEXTURE) {}

gits::OpenGL::CGLTexResource::CGLTexResource(
    GLenum target, GLenum format, GLenum type, GLsizei width, GLsizei height, const GLvoid* ptr)
    : _resource(ptr,
                TexDataSize(format, type, width, height, 1),
                GL_PIXEL_UNPACK_BUFFER,
                RESOURCE_TEXTURE) {}

gits::OpenGL::CGLTexResource::CGLTexResource(GLenum target,
                                             GLenum format,
                                             GLenum type,
                                             GLsizei width,
                                             GLsizei height,
                                             GLsizei depth,
                                             const GLvoid* ptr)
    : _resource(ptr,
                TexDataSize(format, type, width, height, depth),
                GL_PIXEL_UNPACK_BUFFER,
                RESOURCE_TEXTURE) {}

gits::OpenGL::CGLCompressedTexResource::CGLCompressedTexResource(GLenum target,
                                                                 GLsizei width,
                                                                 GLsizei size,
                                                                 const GLvoid* ptr)
    : _resource(
          ptr, CompressedTexDataSize(width, 1, 1, size), GL_PIXEL_UNPACK_BUFFER, RESOURCE_TEXTURE) {
}

gits::OpenGL::CGLCompressedTexResource::CGLCompressedTexResource(
    GLenum target, GLsizei width, GLsizei height, GLsizei size, const GLvoid* ptr)
    : _resource(ptr,
                CompressedTexDataSize(width, height, 1, size),
                GL_PIXEL_UNPACK_BUFFER,
                RESOURCE_TEXTURE) {}

gits::OpenGL::CGLCompressedTexResource::CGLCompressedTexResource(
    GLenum target, GLsizei width, GLsizei height, GLsizei depth, GLsizei size, const GLvoid* ptr)
    : _resource(ptr,
                CompressedTexDataSize(width, height, depth, size),
                GL_PIXEL_UNPACK_BUFFER,
                RESOURCE_TEXTURE) {}

gits::OpenGL::CGLClearTexResource::CGLClearTexResource(
    const void* data, GLuint texture, GLint level, GLenum format, GLenum type)
    : _isNullPtr(data == nullptr) {
  if (!*_isNullPtr) {
    _resource = std::make_unique<CGLGenericResource>(data, texelSize(format, type),
                                                     GL_PIXEL_UNPACK_BUFFER, RESOURCE_TEXTURE);
  }
}

gits::OpenGL::CGLBitmapResource::CGLBitmapResource(GLsizei width,
                                                   GLsizei height,
                                                   const GLubyte* bitmap)
    : _resource(bitmap, BitmapDataSize(width, height), GL_PIXEL_UNPACK_BUFFER, RESOURCE_TEXTURE) {}
