// ===================== begin_copyright_notice ============================
//
// Copyright (C) 2023-2025 Intel Corporation
//
// SPDX-License-Identifier: MIT
//
// ===================== end_copyright_notice ==============================

#pragma once

/*
  The purpose of this file is to provide OpenGL specific functionality that does interact
  with the OpenGL driver. Utility that captures frame buffer content are one such example.
*/

#include "timer.h"

#include <string>
#include <deque>
#include <filesystem>
#include <utility>
#include <optional>

#include "openglTypes.h"
#include "tools.h"
#include "log2.h"
#include "argument.h"

namespace gits {
namespace OpenGL {
GLenum GetTextureTarget(GLint name);
bool ReadPixelsWrapper(GLint x,
                       GLint y,
                       GLint width,
                       GLint height,
                       GLenum format,
                       GLenum type,
                       GLvoid* data,
                       GLenum readbuffer,
                       bool msaa);
void capture_drawbuffer(const std::filesystem::path& directory,
                        const std::string& file_name,
                        bool force_back_buffer,
                        bool dump_depth = true,
                        bool dump_stencil = true);
std::filesystem::path GetPathForImageDumping();
void FrameBufferSave(unsigned frameNumber);
#ifdef GITS_PLATFORM_WINDOWS
void ScreenshotSave(unsigned frameNumber, HWND hWND);
#endif
void capture_bound_texture2D(GLenum target,
                             const std::filesystem::path& directory,
                             const std::string& file_name);
void RestoreFramebufferEXT(
    GLuint targetFBO, GLenum format, GLsizei height, GLsizei width, CBinaryResource& resource);
void RestoreFramebuffer(
    GLuint targetFBO, GLenum format, GLsizei height, GLsizei width, CBinaryResource& resource);
unsigned texUnpackRowSize(GLenum format, GLenum type, GLint texWidth = 0);
unsigned getTexImageSize(GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type);
unsigned TexDataSize(GLenum format, GLenum type, GLsizei width, GLsizei height, GLsizei depth);
unsigned CompressedTexDataSize(GLsizei width, GLsizei height, GLsizei depth, GLsizei imageSize);
unsigned BitmapDataSize(GLsizei width, GLsizei height);
GLint BoundBuffer(GLenum target);
GLint BoundTexture(GLenum target);
GLenum MapAccessBitFieldToEnum(GLbitfield access);
GLbitfield MapAccessEnumToBitField(GLenum access);

std::string GetCurrentProgramShaderText(GLenum shtype);
std::string GetShaderSource(GLint name);
void GetUniformArraySizeAndOffset(
    GLuint program, const GLchar* name, GLint location, GLint& arraySize, GLint& offset);

void SaveProgramBinary(GLuint program, hash_t hash);
void RestoreProgramBinary(GLuint program, hash_t hash);

class PackPixelStoreStateStash {
  std::map<GLenum, GLint> _data;

public:
  PackPixelStoreStateStash();
  void Restore();
  const std::map<GLenum, GLint>& Data() {
    return _data;
  }
};

class UnPackPixelStoreStateStash {
  std::map<GLenum, GLint> _data;

public:
  UnPackPixelStoreStateStash();
  void Restore();
  const std::map<GLenum, GLint>& Data() {
    return _data;
  }
};

class PackPixelBufferBindStateStash {
  GLint _data;

public:
  PackPixelBufferBindStateStash();
  void Restore();
  GLint Data() {
    return _data;
  }
};

class DrawBuffersStateStash {
  std::vector<GLint> _data;

public:
  DrawBuffersStateStash();
  void Restore();
  const std::vector<GLint>& Data() {
    return _data;
  }
};

class ReadBufferStateStash {
  GLenum _data;

public:
  ReadBufferStateStash();
  void Restore();
  GLenum Data() {
    return _data;
  }
};

class FboBindStateStash {
  std::map<GLenum, GLint> _data;
  bool _extFboBlitSupport;

public:
  FboBindStateStash();
  void Restore();
  const std::map<GLenum, GLint>& Data() {
    return _data;
  }
  GLenum ReadTarget();
  GLenum DrawTarget();
  GLint ReadName(); //Returns GL_READ_FRAMEBUFFER bound name
  GLint DrawName(); //Returns GL_DRAW_FRAMEBUFFER bound name
};

class RboBindStateStash {
  GLint _data;

public:
  RboBindStateStash();
  void Restore();
  GLint Data() {
    return _data;
  }
};

class TextureBindStateStash {
  struct {
    GLint name;
    GLenum target;
  } _data;

public:
  TextureBindStateStash(GLenum target);
  void Restore();
  GLint Data() {
    return _data.name;
  }
};

class ScissorStateStash {
  std::vector<int> _data; //x, y, width, height, enabled
public:
  ScissorStateStash();
  void Restore();
  std::vector<int> Data() {
    return _data;
  }
};

typedef std::vector<GLuint> CNameVector; // Stores names generated by glGen/glCreate

class BufferStateStash {
  static const GLuint bufferTargetCount = 6;
  static const GLenum bufferBindingTargets[bufferTargetCount];
  CNameVector _data;

public:
  BufferStateStash();
  void Restore();
};

class MapBuffer {
  GLenum _target;
  void* _ptr;

public:
  MapBuffer(GLenum target, GLint buffer);
  MapBuffer(const MapBuffer& other) = delete;
  MapBuffer& operator=(const MapBuffer& other) = delete;
  ~MapBuffer();
  void* Data() {
    return _ptr;
  }
};

//Helper class for unique glsl names generation (programs shaders names scope)
class GLSLUnique {
private:
  static std::set<GLuint>& UsedNames() { //Keep all used shader names
    typedef std::set<GLuint> name_set;
    INIT_NEW_STATIC_OBJ(usedNames, name_set);
    return usedNames;
  }
  GLSLUnique() {}

public:
  static void UseName(GLuint name) {
    UsedNames().insert(name);
  }
  static GLuint GenUniqueName() { //Generates unique shader name
    UsedNames().insert((*UsedNames().rbegin()) + 1);
    return (*UsedNames().rbegin());
  }
};

//Depth GL_FLOAT format to GL_RGB/GL_RGBA data converter
std::vector<uint8_t> DepthToRgbSpectrum(std::vector<GLfloat>& depthData, bool alpha);
std::vector<uint8_t> DepthToRgbGrey(std::vector<GLfloat>& depthData, bool alpha);
std::vector<uint8_t> DepthToRgb(std::vector<GLfloat>& depthData, bool alpha);

//Stencil GL_UNSIGNED_INT_24_8 format to GL_RGB/GL_RGBA data converter
std::vector<uint8_t> StencilToRgb(std::vector<uint32_t>& depthStencilData, bool alpha);

bool MakeCurrentIfDrawableExists(void* context);
bool SetCurrentContext(void* context);
void* GetCurrentContextAPI();
TBuffersState ESBufferState();

bool IsGlGetTexImagePresentOnGLES();
bool IsGlGetCompressedTexImagePresentOnGLES();

bool IsGlGetTexAndCompressedTexImagePresentOnGLES();

class StatePrinter {
  class Object {
  public:
    virtual void Write() = 0;
    virtual ~Object() {}
  };
  class RBO : public Object {
    GLint _name;
    GLenum _internalFormat;
    GLint _msaaSamples;

  public:
    RBO(GLint name);
    void Write();
  };
  class Texture : public Object {
    GLint _name;
    GLenum _target;
    GLenum _internalFormat;
    GLint _msaaSamples;
    GLenum _texture;

  public:
    Texture(GLenum target, GLint name, GLenum texture);
    void Write();
  };
  class FBO : public Object {
    GLint _name;
    GLenum _target;
    std::map<GLenum, std::shared_ptr<Object>> _attachments;

  public:
    FBO(GLenum target, GLint name);
    void Write();
  };
  class GLSLPrograms : public Object {
    GLint _name;

  public:
    GLSLPrograms(GLint name) : _name(name) {}
    void Write();
  };
  class GLSLPipelines : public Object {
    GLint _name;

  public:
    GLSLPipelines(GLint name) : _name(name) {}
    void Write();
  };
  class ARBProgram : public Object {
    GLenum _target;
    GLint _name;

  public:
    ARBProgram(GLenum target, GLint name) : _target(target), _name(name) {}
    void Write();
  };
  class BoundBuffers : public Object {
    GLenum _target;
    GLint _buffer;

  public:
    BoundBuffers(GLenum target, GLint buffer) : _target(target), _buffer(buffer){};
    void Write();
  };
  std::vector<std::shared_ptr<Object>> _objects;

public:
  StatePrinter();
  void PrintToLog();
};

template <typename T>
std::string ToStr(const T& value) {
  if constexpr (std::is_pointer_v<T>) {
    if (value == nullptr) {
      return "NULL";
    }
    std::ostringstream oss;
    oss << "0x" << std::hex << reinterpret_cast<uintptr_t>(value);
    return oss.str();
  } else if constexpr (std::is_arithmetic_v<T>) {
    return std::to_string(value);
  } else if constexpr (std::is_convertible_v<T, std::string>) {
    return std::string(value);
  } else {
    // Template-dependent static_assert: sizeof(T) == 0 ensures this assertion is only
    // evaluated during template instantiation, not during initial template parsing.
    // Using static_assert(false, ...) would cause GCC to fail compilation immediately
    // during the parsing phase, even if this branch is never instantiated.
    static_assert(sizeof(T) == 0, "ToStr specialization required for this type");
  }
  return "";
}
template <>
std::string ToStr<unsigned char*>(unsigned char* const& value);
template <>
std::string ToStr<GLenum>(const GLenum& value);
template <>
std::string ToStr<GLboolean>(const GLboolean& value);
template <>
std::string ToStr<PIXELFORMATDESCRIPTOR>(const PIXELFORMATDESCRIPTOR& pfd);

void CleanResources();
void DestroyContext(void* ctx);
void DestroyAllContexts();

size_t GetPatchParameterValuesCount(GLenum pname);

GLenum GetTargetOfTextureOrCrash(GLuint name);
bool isTrackTextureBindingWAUsed();
bool isSchedulefboEXTAsCoreWA();

template <typename T>
class LocationMap {
private:
  struct LocationData {
    T originalBase;
    T currentBase;
  };
  std::map<T, LocationData> _map;

public:
  LocationMap() : _map{} {};
  void insert(const T& begin, const T& end, const T& currentBase) {
    LocationData locData{begin, currentBase};
    for (auto i = begin; i < end; i++) {
      _map.insert(std::make_pair(i, locData));
    }
  }

  std::optional<LocationData> find(const T& key) {
    auto it = _map.find(key);
    if (it != _map.end()) {
      return it->second;
    } else {
      return std::nullopt;
    }
  }
};
} // namespace OpenGL
} // namespace gits
