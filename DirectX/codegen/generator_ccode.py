#!/usr/bin/python

# ===================== begin_copyright_notice ============================
#
# Copyright (C) 2023-2026 Intel Corporation
#
# SPDX-License-Identifier: MIT
#
# ===================== end_copyright_notice ==============================
from generator_helpers import *
from intermediates import Parameter, Function, Struct
from typing import Union

# Used to find whether a type is trivial
TRIVIAL_TYPES = {"UINT", "SIZE_T", "INT", "FLOAT", "BOOL", "LARGE_INTEGER", "INT8", "INT32", "INT64", 
                "UINT8", "UINT16", "UINT32", "UINT64", "DOUBLE", "BYTE", "REFIID", "REFGUID", "REFCLSID", "DWORD", "LONG",
                "DXGI_USAGE", # UINT
                "D3D12_PRIMITIVE_TOPOLOGY", # D3D_PRIMITIVE_TOPOLOGY
                "D3D12_PRIMITIVE" # D3D_PRIMITIVE
}
def initialize_trivial_types(enums):
    global TRIVIAL_TYPES
    TRIVIAL_TYPES.update(enum.name for enum in enums)


def print_parameter_info(origin: Union[Function, Struct], parameter):
    is_command_argument = isinstance(origin, Function)
    name = to_lower_camel_case(parameter.name)
    parent_info = ''
    # Optional argument for struct members
    if not is_command_argument:
        parent_info = ', info'

    str = f'CppParameterInfo {name}Info("{parameter.type}", "{name}"{parent_info});'
    if parameter.is_pointer:
        str += f'{name}Info.isPtr = true;'
    if parameter.sal_size:
        # The size can be hardcoded or another parameter
        if parameter.sal_size.isdigit():
            str += f'{name}Info.size = {parameter.sal_size};'
        else:
            str += f'{name}Info.size = {get_sal_size_value(parameter, is_command_argument)}'
    elif parameter.is_array and parameter.size:
        str += f'{name}Info.size = {parameter.size};'
    return str

def is_input_sal(sal):
    if "_Out_" in sal:
        return False
    return True

def get_sal_size_value(parameter, is_command_argument):
    str = "0; // ERROR_PROCESSING_SAL: " + parameter.sal + "\n"

    # Some size sals have expressions that would add too much complexity
    custom_values = {
        # ID3D12GraphicsCommandListSetComputeRoot32BitConstants
        'Num32BitValuesToSet*sizeof(UINT)': 'c.Num32BitValuesToSet_.value * sizeof(UINT);',
        # ID3D12GraphicsCommandList1SetSamplePositions
        'NumSamplesPerPixel*NumPixels': 'c.NumSamplesPerPixel_.value * c.NumPixels_.value;',
        # ID3D12GraphicsCommandList5RSSetShadingRate
        'D3D12_RS_SET_SHADING_RATE_COMBINER_COUNT': 'D3D12_RS_SET_SHADING_RATE_COMBINER_COUNT;'
    }
    if parameter.sal_size in custom_values:
        return custom_values[parameter.sal_size]

    if parameter.sal_size.startswith("_Inexpressible_"):
        return str
    
    input_size_sals = ["__Field_size_full", "__Field_size_bytes_full", "__Field_size",
                        "__In_reads", "__In_count", "__In_opt_count", "__Inout_updates_bytes",
                        "__Out_writes"]
    for input_size_sal in input_size_sals:
        if parameter.sal.startswith(input_size_sal):
            sal_size = parameter.sal_size
            sal_size_decorator = ""
            if sal_size[0] == '*':
                sal_size = sal_size[1:]
                sal_size_decorator = "*"
            if ',' in sal_size:
                sal_size = sal_size.split(',')[0]
            if is_command_argument:
                str = f'{sal_size_decorator}c.{sal_size}_.value;'
            else:
                str = f'{sal_size_decorator}value.{sal_size};'
    return str

def to_lower_camel_case(name):
    if not name:
        return name
    
    # Make first letter lowercase if it exists and is uppercase
    if name and name[0].isupper():
        name = name[0].lower() + name[1:]
    
    return name

def is_trivial_parameter(parameter):
    global TRIVIAL_TYPES
    if parameter.is_interface or parameter.is_interface_creation:
        return False
    if parameter.is_pointer or parameter.is_pointer_to_pointer:
        return False
    if parameter.is_array:
        return False
    if parameter.type in TRIVIAL_TYPES:
        return True
    return False

def is_custom_struct(struct):
    # Note: Structs with interfaces are handled separately (via argumentToCpp) so 
    # they are not custom structures nor autogenerated

    # Structs with unions need special handling in toCpp functions
    if struct.has_unions:
        return True
    
    # Other custom structs
    custom_structs = {
        "DXGI_FRAME_STATISTICS", # LARGE_INTERGER is not parsed correctly
        "D3D12_PIPELINE_STATE_STREAM_DESC" # SAL for size is _Inexpressible_
    }
    if struct.name in custom_structs:
        return True
    return False

def get_interface_declaration(function):
    str = ''
    if not is_interface_creation(function):
        return str
    previous_param = Parameter()
    for param in function.params:
        if param.is_interface_creation:
            if not param.sal_size:
                if previous_param.type == 'REFIID' and param.is_pointer_to_pointer and param.type == 'void':
                    str += f'stream.addInterface(c.{param.name}_.key, c.{previous_param.name}_.value);'
                else:
                    str += f'stream.addInterface(c.{param.name}_.key, IID_{param.type});'
            else:
                str += f'// TODO ARRAY OF COM OBJECTS'
        previous_param = param
    return str

def generate_ccode_files(context, out_path):
    initialize_trivial_types(context['enums'])
    additional_context = {
        'is_custom_struct': is_custom_struct,
        'print_parameter_info': print_parameter_info,
        'is_trivial_parameter': is_trivial_parameter,
        'to_lower_camel_case': to_lower_camel_case,
        'get_interface_declaration': get_interface_declaration
    }
    files_to_generate = [
        'ccodeLayerAuto.h',
        'ccodeLayerAuto.cpp',
        'ccodeStructsAuto.h',
        'ccodeStructsAuto.cpp',
        'ccodeUtilsAuto.h',
        'ccodeUtilsAuto.cpp'
    ]

    for file_name in files_to_generate:
        generate_file(context | additional_context, file_name, out_path)