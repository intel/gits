#!/usr/bin/python

# ===================== begin_copyright_notice ============================
#
# Copyright (C) 2023-2025 Intel Corporation
#
# SPDX-License-Identifier: MIT
#
# ===================== end_copyright_notice ==============================

from generator_vulkan import (
    get_functions,
    get_structs,
    get_enums,
    FuncType,
    FuncLevel,
    Token,
    Argument,
    ReturnValue,
    VkStruct,
    Field,
    VkEnum,
    Enumerator,
)

from collections import namedtuple
from datetime import datetime
from enum import auto, Enum, unique
from pathlib import Path
from typing import TypeVar
import inspect
import platform
import re
import shutil
import textwrap

import mako.template
import mako.exceptions



Versioned = TypeVar('Versioned', Token, VkStruct)  # Enums aren't versioned.


AUTO_GENERATED_HEADER = f"""
//
// FILE AUTO-GENERATED BY THE GITS CODE GENERATOR. DO NOT MODIFY DIRECTLY.
// GENERATED ON: {datetime.now()}
//
""".strip('\n')


# Vulkan types categorized
# TODO: these are almost constants, should names be in ALL_CAPS?

vulkan_flags: list[str] = []
vulkan_flags64: list[str] = []
for enum in get_enums():
    if 'FlagBits' in enum.name:
        flags_name = enum.name.replace('FlagBits', 'Flags')
        if enum.size == 64:
            vulkan_flags64.append(flags_name)
        else:
            vulkan_flags.append(flags_name)

vulkan_uint32: list[str] = vulkan_flags + [
    'uint32_t',
    'bool32_t',
    'VkBool32',
]
vulkan_uint64: list[str] = vulkan_flags64 + [
    'VkDeviceSize',
    'VkDeviceAddress',
]

vulkan_unions: list[str] = []
for struct in get_structs():
  if struct.type == 'union':
    vulkan_unions.append(struct.name.rstrip('_'))

vulkan_other_primitives: list[str] = [
    "bool",
    "int32_t",
    "int64_t",
    "uint8_t",
    "uint16_t",
    "uint32_t",
    "uint64_t",
    "size_t",
    "float",
    "double",
    "void*",
    "void**",
    "nullptr",
]

vulkan_enums: list[str] = [enum.name for enum in get_enums()]

# TODO: Remove the rstrip once '_' is removed from struct names in generator data.
vulkan_structs: list[str] = [struct.name.rstrip('_') for struct in get_structs()]

primitive_types: list[str] = (
    vulkan_enums
    + vulkan_uint32
    + vulkan_uint64
    + vulkan_unions
    + vulkan_other_primitives
)

opaque_dispatchable_handles: list[str] = [
    "VkInstance",
    "VkPhysicalDevice",
    "VkDevice",
    "VkQueue",
    "VkCommandBuffer",
]

opaque_nondispatchable_handles: list[str] = [
    'VkSemaphore',
    'VkFence',
    'VkDeviceMemory',
    'VkBuffer',
    'VkImage',
    'VkEvent',
    'VkQueryPool',
    'VkBufferView',
    'VkImageView',
    'VkShaderModule',
    'VkPipelineCache',
    'VkPipelineLayout',
    'VkRenderPass',
    'VkPipeline',
    'VkDescriptorSetLayout',
    'VkSampler',
    'VkDescriptorPool',
    'VkDescriptorSet',
    'VkFramebuffer',
    'VkCommandPool',
    'VkSamplerYcbcrConversion',
    'VkDescriptorUpdateTemplate',
    'VkSurfaceKHR',
    'VkSwapchainKHR',
    'VkDisplayKHR',
    'VkDisplayModeKHR',
    'VkDebugReportCallbackEXT',
    'VkObjectTableNVX',
    'VkIndirectCommandsLayoutNVX',
    'VkDebugUtilsMessengerEXT',
    'VkValidationCacheEXT',
    'VkPerformanceConfigurationINTEL',
    'VkVideoSessionKHR',
    'VkVideoSessionParametersKHR',
    'VkAccelerationStructureKHR',
    'VkDeferredOperationKHR',
]

other_opaque_handles: list[str] = [
    "HANDLE",
    "HWND",
    "HINSTANCE",
    "HMONITOR",
    "D3DKMT_HANDLE",
]

opaque_handles: list[str] = (
    opaque_dispatchable_handles
    + opaque_nondispatchable_handles
    + other_opaque_handles
)

vulkan_mapped_types: list[str] = opaque_dispatchable_handles
vulkan_mapped_types_nondisp: list[str] = opaque_nondispatchable_handles


# Data for CCode

types_needing_name_registration: list[str] = [
    "StringArray",
    "ByteStringArray",
]

types_not_needing_declaration: list[str] = (
    [
        "NullWrapper",
        "VoidPtr",
    ]
    + vulkan_enums
    + vulkan_uint32
    + vulkan_uint64
    + vulkan_other_primitives
    + opaque_handles
)


def decimal_str_to_hex(decimal_text: str) -> str:
    """
    Convert text from decimal to hexadecimal.

    To match old generator behavior, negative numbers are in parentheses
    (except for the minus sign). Example: '-13' -> '-(0xd)'
    """
    decimal_value: int = int(decimal_text)
    absolute_value: int = abs(decimal_value)
    if decimal_value < 0:
        return f'-({hex(absolute_value)})'
    else:
        return hex(decimal_value)

def version_suffix(version: int) -> str:
    """Return a version suffix (like '_V1'), empty for version 0."""
    if version <= 0:
        return ''
    else:
        return f'_V{version}'

def make_id(name: str, version: int) -> str:
    """Return an ID (like 'ID_GL_BEGIN_V1')."""
    id_ = re.sub('([a-z])([A-Z])', r'\g<1>_\g<2>', name)
    id_ = re.sub('([0-9])D', r'_\g<1>D_', id_)
    id_ = id_.rstrip('_').upper()

    return f'ID_{id_}{version_suffix(version)}'

def make_cname(name: str, version: int) -> str:
    """Return a Cname (like 'CglBegin_V1')."""
    return f'C{name}{version_suffix(version)}'

def make_ctype(type_name: str, wrap_type: str = '', name: str = '') -> str:
    """
    Return a Ctype (name of C++ class wrapping a type).

    Parameters:
        type_name: Type, as written in generator (like 'const float*').
        wrap_type: Wrap type (like 'Cfloat::CSArray').
        name: Name of struct field (like 'pQueuePriorities').

    Returns:
        A Ctype (like 'Cfloat::CSArray').
    """
    if wrap_type:  # Wrap types override deduced Ctypes.
        return wrap_type

    type, array = split_arrays_from_name(type_name)
    bare_type: str = undecorated_type(type)

    if '*' in type_name:
        if bare_type == 'void' and name == 'pNext':
            return 'CpNextWrapper'
        elif bare_type in vulkan_structs:
            return f'C{bare_type}'
        else:
            return f'C{bare_type}::CSArray'
    elif array:
        return f'C{type}::CSArray'
    elif bare_type in vulkan_uint32:
        return 'Cuint32_t'
    elif bare_type in vulkan_uint64:
        return 'Cuint64_t'
    else:
        return f'C{bare_type}'

def make_ctypedata(type_name: str, wrap_type: str = '', name: str = '') -> str:
    """
    Return a C*Data type (used in StructStorage).

    Parameters:
        type_name: Type, as written in generator (like 'const float*').
        wrap_type: Wrap type (like 'Cfloat::CSArray').
        name: Name of struct field (like 'pQueuePriorities').

    Returns:
        A C*Data type (like 'CfloatDataArray').
    """
    ctype: str = make_ctype(type_name, wrap_type, name)
    type, _ = split_arrays_from_name(type_name)
    bare_type: str = undecorated_type(type)

    # Special cases.
    if not wrap_type:
        if '*' in type and bare_type == 'void' and name != 'pNext':
            return 'CvoidPtrData'

    # Wrapped types conversion.
    type_replacements: dict[str, str] = {
        '::CSArray': 'DataArray',
        '::CSMapArray': 'DataArray',
        'ArrayOfArrays': 'DataArrayOfArrays',
        'Array': 'DataArray',
    }
    for old, new in type_replacements.items():
        if old in ctype:
            return ctype.replace(old, new)

    # Nothing matched, use generic logic.
    return ctype + 'Data'

def undecorated_type(type_name: str) -> str:
    """Strip the type to its core, e.g., const float* to just float."""
    return type_name.replace('const', '').strip('* ')

def does_arg_need_ampersand(type_name: str, wrap_type: str = '') -> bool:
    """Determine whether an Argument may ever need a '&' prefix in CCode."""
    raw_type: str = undecorated_type(type_name)
    num_ptr: int = type_name.count('*')

    if raw_type in vulkan_unions and num_ptr == 1:
        return True
    elif raw_type in vulkan_structs and not wrap_type.endswith('Array'):
        return True
    else:
        return False

def categorize_argument(type_name: str) -> str:
    """
    Categorize the type of an Argument.

    The range of possible categories is defined in C++ code.
    """
    raw_type: str = undecorated_type(type_name)

    if raw_type in opaque_handles:
        return 'OPAQUE_HANDLE'
    elif raw_type in vulkan_enums:
        return 'ENUM'
    elif raw_type in primitive_types:
        return 'PRIMITIVE_TYPE'
    elif raw_type in vulkan_structs:
        return 'STRUCT'
    elif 'void*' in type_name:
        return 'OTHER'  # void* or void**
    else:
        print(f"Warning: type {type_name} is of unknown category.")
        return 'OTHER'

def make_func_type_flags(func_type: FuncType) -> str:
    """Convert FuncType into GITS' C++ representation string."""
    return ' | '.join(f'GITS_VULKAN_{flag.name}_APITYPE' for flag in func_type)

def make_inherit_type(func_type: FuncType) -> str:
    """Return name of the parent class for a function of this type."""
    if len(func_type) > 1:
        raise ValueError("Function has multiple types, unclear what to inherit from.")

    match func_type:
        case FuncType.CREATE_BUFFER:
            return 'CBufferFunction'
        case FuncType.CREATE_IMAGE:
            return 'CImageFunction'
        case FuncType.QUEUE_SUBMIT:
            return 'CQueueSubmitFunction'
        case _:
            return 'CFunction'

def get_indent(s: str) -> str:
    """Return the base indentation of given code as a string."""
    # In case of multiline strings, first line should be the least indented.
    match = re.match(r'\s*', s)
    if match is None:
        return ''
    else:
        return match.group()

def wrap_in_if(condition: str, code: str, indent: str = '  ') -> str:
    """Wrap a multiline string in a C++ if statement."""

    orig_indent = get_indent(code)

    # So we don't double orig_indent when indenting everything at the end.
    # Dedent doesn't accept amount, but it should dedent exactly by orig_indent.
    dedented_code = textwrap.dedent(code)

    # Indent by one level.
    indented_code = textwrap.indent(dedented_code, indent)

    if_statement = f'if ({condition}) {{\n{indented_code}\n}}'

    # Indent everything by original indent amount.
    return textwrap.indent(if_statement, orig_indent)

def split_functions_by_level(
    vk_functions: list[Token],
) -> dict[FuncLevel, list[Token]]:
    """
    Separate Vulkan functions (tokens) by their level.

    Parameters:
        vk_functions: List of Vulkan functions of various levels.

    Returns:
        A dict, mapping levels to lists of functions of each level.
    """
    functions_by_level: dict[FuncLevel, list[Token]] = {}
    functions_by_level[FuncLevel.PROTOTYPE] = []
    functions_by_level[FuncLevel.GLOBAL] = []
    functions_by_level[FuncLevel.INSTANCE] = []
    functions_by_level[FuncLevel.DEVICE] = []

    for token in vk_functions:
        functions_by_level[token.level].append(token)

    return functions_by_level

def without_older_versions(input: list[Versioned]) -> list[Versioned]:
    """
    Filter out older versions of Vulkan tokens or structs from a list.

    Parameters:
        input: List of tokens or structs.

    Returns:
        A list containing only newest versions of items from input.
    """
    newest_token_versions: dict[str, Versioned] = {}

    for item in input:
        newest_so_far: Versioned | None = newest_token_versions.get(item.name)
        if newest_so_far is None or newest_so_far.version < item.version:
            newest_token_versions[item.name] = item

    return list(newest_token_versions.values())

def dependency_ordered(
    structs: list[VkStruct],
    *,
    use_undecorated_types: bool = False,
) -> list[VkStruct]:
    """
    Order structs by putting dependencies first.

    If given struct S contains structs A and B, A and B will be ordered before
    S to avoid undeclared identifier errors in C++ code.

    To avoid duplicates, only newest struct versions are kept.

    Parameters:
        structs: List of structs to be ordered by dependencies.
        use_undecorated_types: If bare types are to be used for comparison.

    Returns:
        A copy of `structs`, reordered to avoid undeclared identifier errors.
    """
    structs = without_older_versions(structs)

    result: list[VkStruct] = []

    struct_type_names: set[str] = set((s.name for s in structs))
    declared_structs: list[str] = []
    while len(declared_structs) < len(structs):
        for struct in structs:
            if struct.name not in declared_structs:
                # True when none of the struct's fields are undeclared structs.
                all_dependencies_met: bool = True

                for field in struct.fields:
                    bare_type: str = undecorated_type(field.type)
                    type_: str = bare_type if use_undecorated_types else field.type

                    not_yet_declared: bool = type_ not in declared_structs
                    is_a_struct: bool = type_ in struct_type_names
                    if not_yet_declared and is_a_struct:
                        all_dependencies_met = False

                if all_dependencies_met:
                    result.append(struct)
                    declared_structs.append(struct.name)

    return result

def make_flagbits_type_cast(type: str) -> str:
    """
    Return a C++ type cast to a *FlagBits enum if type is a *Flags uint.
    """
    if 'Flags' in type:
        corresponding_enum = type.replace('Flags', 'FlagBits')
        if corresponding_enum in vulkan_enums:
            return f'({corresponding_enum})'

    return ''

def make_struct_field_log_code(field: Field) -> str:
    """Return C++ code for logging a Field."""
    result = f'" {field.name}: "'

    type_cast = make_flagbits_type_cast(field.type)

    if field.name == 'pNext':
        result += ' << (PNextPointerTypeTag)c.pNext << ", " << '
    elif field.count is not None:
        conditions = ''

        if '[' not in field.type:  # Skip nullptr check for arrays on the stack.
            conditions += f'(c.{field.name} != nullptr)'
        if field.log_condition is not None:
            conditions += f' && ({field.log_condition})'

        count: str = field.count
        if not count.isdigit():
            count = f'c.{count}'

        if conditions:
            result += inspect.cleandoc(f'''
            ;
              if ({conditions}) {{
                oss << "{{";
                for (uint32_t i = 0; i < (uint32_t){count}; ++i) {{
                  oss << " [" << i << "]:" << ToStr({type_cast}c.{field.name}[i]);
                }}
                oss << " }}";
              }} else {{
                oss << "{{ 0 }}";
              }}
''')
        else:
            result += inspect.cleandoc(f'''
            ;
              oss << "{{";
              for (uint32_t i = 0; i < (uint32_t){count}; ++i) {{
                oss << " [" << i << "]:" << ToStr({type_cast}c.{field.name}[i]);
              }}
              oss << " }}";
''')
        result += '\n  oss << ", " << '
    else:
        result += f' << ToStr({type_cast}c.{field.name}) << ", " << '

    return result

def make_struct_log_code(fields: list[Field]) -> str:
    """Return C++ code for logging Fields of a VkStruct."""
    fields_str = 'oss << "{" << '

    field: Field
    for field in fields:
        fields_str += make_struct_field_log_code(field)

    fields_str = fields_str.removesuffix(' << ", " << ')
    fields_str += ' << " }";'

    fields_str = fields_str.replace('", " << " ', '", ')
    fields_str = fields_str.replace('"{" << " ', '"{ ')

    return fields_str

def make_argument_log_code(argument: Argument, count_is_a_pointer: bool) -> str:
    """Return C++ code for logging an Argument."""
    result = f'", {argument.type} {argument.name}="'

    type_cast = make_flagbits_type_cast(argument.type)

    if argument.count is not None:
        additional_conditions: str = ''
        dereference: str = ''
        if '[' not in argument.type:  # Skip nullptr check for arrays on the stack.
            additional_conditions = f'({argument.name} != nullptr)'
            if count_is_a_pointer:
                additional_conditions += f' && ({argument.count} != nullptr)'
                dereference = '*'

        result += inspect.cleandoc(f'''
            ;
                if ({additional_conditions}) {{
                  LOG_TRACE << "{{";
                  for (uint32_t i = 0; i < (uint32_t){dereference}{argument.count}; ++i) {{
                    LOG_TRACE << " [" << i << "]:" << ToStr({type_cast}{argument.name}[i]);
                  }}
                  LOG_TRACE << " }}";
                }} else {{
                  LOG_TRACE << "{{ 0 }}";
                }}
            ''')
        result += '\n'
        result += '    LOG_TRACE << '
    else:
        result += f' << ToStr({type_cast}{argument.name}) << '

    return result

def make_token_log_code(arguments: list[Argument]) -> str:
    """Return C++ code for logging Arguments of a Token."""
    # Ignore unnamed arguments of type 'void'.
    arguments = [arg for arg in arguments if arg.type != 'void']
    if not arguments:
        return '"( )"'

    arguments_str = ''

    argument: Argument
    for argument in arguments:
        count_is_a_pointer: bool = False
        if argument.count:
            for arg2 in arguments:
                if argument.count in arg2.name and '*' in arg2.type:
                    count_is_a_pointer = True

        arguments_str += make_argument_log_code(argument, count_is_a_pointer)

    arguments_str = '"( ' + arguments_str.lstrip('", ')
    arguments_str += '" )"'

    return arguments_str

@unique
class FieldInitType(Enum):
    """Type of field initialization code to generate."""

    ARGUMENT_VALUE = auto()
    ARGUMENT_ORIGINAL = auto()
    STRUCT_STORAGE_VALUE = auto()

def make_value_field_inits(struct: VkStruct, type_: FieldInitType) -> str:
    """Return C++ field initialization code for Value() or Original() functions."""
    result: str = ''

    vkless_name: str = struct.name.removeprefix('Vk')
    if type_ is FieldInitType.ARGUMENT_ORIGINAL:
        vkless_name += 'Original'

    for field in struct.fields:
        arrayless_type, array = split_arrays_from_name(field.type)
        array_length: str = array.strip('[]')

        pointer_type: str
        pointer_name: str
        dereference: str
        match type_:
            case FieldInitType.ARGUMENT_VALUE:
                pointer_type = f'{arrayless_type}*'
                pointer_name = f'{field.name}Values'
                dereference  = f'**_{field.name}'
            case FieldInitType.ARGUMENT_ORIGINAL:
                pointer_type = f'{arrayless_type}*'
                pointer_name = f'{field.name}ValuesOriginal'
                dereference  = f'_{field.name}->Original()'
            case FieldInitType.STRUCT_STORAGE_VALUE:
                pointer_type = 'auto'
                pointer_name = f'{field.name}Values'
                dereference  = f'**_{field.name}'

        if array:
            result += inspect.cleandoc(f'''
            {pointer_type} {pointer_name} = {dereference};
            if ({pointer_name} != nullptr) {{
              for (int i = 0; i < {array_length}; i++)
                _{vkless_name}->{field.name}[i] = {pointer_name}[i];
            }} else {{
              throw std::runtime_error(EXCEPTION_MESSAGE);
            }}
            ''') + '\n'
        elif (type_ is FieldInitType.STRUCT_STORAGE_VALUE and
                struct.pass_struct_storage and
                field.name == 'pNext'):
            result += f'_{vkless_name}->{field.name} = &_baseIn;\n'
        else:
            result += f'_{vkless_name}->{field.name} = {dereference};\n'

    return result.strip()

def split_bitfield_width_from_name(name: str) -> tuple[str, str]:
    """
    Separate a bit-field width annotation from variable or type name.

    Parameters:
        name: Name that may contain a bit-field width annotation.

    Returns:
        Tuple of (name, bit-field width). Examples:

        'uint32_t:24' -> ('uint32_t', ':24')
        'mask : 8' -> ('mask', ' : 8')
    """
    bitfield_width: str = ''

    regex: str = r'[ \t]*:[ \t]*[0-9]+'
    match = re.search(regex, name)
    if match:
        name = re.sub(regex, '', name)
        bitfield_width = match.group(0)

    return (name.strip(), bitfield_width)

def split_arrays_from_name(name_with_array: str) -> tuple[str, str]:
    """
    Separate array declarations from variable or type name.

    Parameters:
        name_with_array: Name that may contain array declarations.

    Returns:
        Tuple of (name, array). Examples:

        'baseAndCount [2]' -> ('baseAndCount', '[2]')
        'matrix[3][4]' -> ('matrix', '[3][4]')
    """
    array_regex: str = r'\[[0-9_]+\]'
    matches = re.findall(array_regex, name_with_array)
    if matches:
        name: str = re.sub(array_regex, '', name_with_array)
        arrays: str = ''.join(matches)
    else:
        name: str = name_with_array
        arrays: str = ''

    return (name.strip(), arrays.strip())

NameTypeArrayBitfield = namedtuple(
    "NameTypeArrayBitfield",
    [
        "name",
        "type",
        "array",
        "bitfield",
    ],
)

def split_name_type_array_bitfield(raw_name: str, raw_type: str) -> NameTypeArrayBitfield:
    """
    Return name and type separately from any possible bitfield width or array declarations.

    Function argument's or struct field's name or type can contain an array
    declaration, like 'VkFragmentShadingRateCombinerOpKHR[2]' in Vulkan or
    'baseAndCount[2]' in OpenGL.

    They can also contain a bitfield width annotation, like 'uint32_t:8'.

    Extract an array declaration from name or type and return a named tuple of:
        name: Name with array/bitfield parts removed.
        type: Type with array/bitfield parts removed.
        array: Array declaration (or empty string) extracted from name or type.
        bitfield: Bit-field width annotation (or empty string) extracted from name or type.
    """
    name: str
    type: str

    name_array: str
    type_array: str
    name, name_array = split_arrays_from_name(raw_name)
    type, type_array = split_arrays_from_name(raw_type)
    assert not (name_array and type_array), (
        "Argument name and type can't both have array declarations.")
    array: str = name_array or type_array

    name_bitfield: str
    type_bitfield: str
    name, name_bitfield = split_bitfield_width_from_name(name)
    type, type_bitfield = split_bitfield_width_from_name(type)
    assert not (name_bitfield and type_bitfield), (
        "Argument name and type can't both have bit-field width annotations.")
    bitfield: str = name_bitfield or type_bitfield

    return NameTypeArrayBitfield(name, type, array, bitfield)

def args_to_str(
    args: list[Argument],
    format_string: str,
    rstrip_string: str = '',
) -> str:
    """
    Format Vulkan function call arguments as string.

    Each argument will get square brackets and their contents removed, then
    `format_string.format(...)` will be run on it. The results will all get
    concatenated and returned.

    Placeholder strings supported for formatting are:
        name: Name with array part removed.
        type: Type with array part removed.
        array: Array declaration (or empty string) extracted from name or type.
        wrap_params: wrap_params from generator (if present) or name (described above).
        ctype: Name of the class wrapping this argument, e.g. 'CVkDevice'.
        category: One of categories defined in C++ code, e.g., 'PRIMITIVE_TYPE'.
        num_ptr: Pointer count of type, e.g., 2 for 'int**'.
        needs_ampersand: Whether it may ever need a '&' prefix in CCode.

    Parameters:
        args: Parameters of the Vulkan function.
        format_string: Format of one argument, with placeholders like '{name}'.
        rstrip_string: String to rstrip the result with; defaults to ''.

    Returns:
        A C++ arguments string. Examples:

            'int foo, float bar[2], bool baz'
            '*_foo, *_bar, *_baz'
    """

    args_str = ''

    arg: Argument
    for arg in args:
        c: NameTypeArrayBitfield = split_name_type_array_bitfield(arg.name, arg.type)
        name, type, array, bitfield = c
        if bitfield:
            raise ValueError("Arguments can't have bitfield width specified.")

        wrap_type: str = arg.wrap_type or ''
        wrap_params: str = arg.wrap_params or name
        ctype: str = make_ctype(arg.type, wrap_type, name)
        num_ptr: int = type.count('*')
        needs_ampersand = str(does_arg_need_ampersand(type, wrap_type)).lower()

        # Compute only when needed, to avoid bogus 'unknown category' warnings.
        category: str = ''
        if '{category}' in format_string:
            category = categorize_argument(type)

        args_str += format_string.format(
            name=name,
            type=type,
            array=array,
            wrap_params=wrap_params,
            ctype=ctype,
            category=category,
            num_ptr=num_ptr,
            needs_ampersand=needs_ampersand,
        )

    return args_str.rstrip(rstrip_string)

def fields_to_str(
    fields: list[Field],
    format_string: str,
    rstrip_string: str = '',
    *,
    struct_name: str | None = None,
) -> str:
    """
    Format Vulkan struct fields as string.

    Each field will have values calculated to replace the placeholders, then
    `format_string.format(...)` will be run on it. Resulting strings will
    all be concatenated, rstripped using the given value and returned.

    Placeholder strings supported for formatting are:
        name: Name with array/bitfield parts removed.
        type: Type with array/bitfield parts removed.
        array: Array declaration (or empty string) extracted from name or type.
        bitfield: Bit-field width annotation (or empty string) extracted from name or type.
        arguments: Arguments to each field's constructor.
        ctype: Name of the class wrapping this argument, e.g. 'Cfloat'.
        ctypedata: C*Data type made from C type; e.g. 'CfloatData'.

    Parameters:
        fields: Fields of the Vulkan struct.
        format_string: Format of one field with placeholders like `{name}`.
        rstrip_string: String to rstrip the result with; defaults to ''.

    Returns:
        A C++ fields string. Examples:

            'uint32_t foo:24, uint32_t bar:8, float baz[4]'
            '_foo, _bar, _baz'
    """

    fields_str = ''

    field: Field
    for field in fields:
        c: NameTypeArrayBitfield = split_name_type_array_bitfield(field.name, field.type)
        name, type, array, bitfield = c

        wrap_type: str = field.wrap_type or ''
        ctype: str = make_ctype(field.type, wrap_type, name)
        ctypedata: str = make_ctypedata(field.type, wrap_type, name)

        if struct_name:
            vkless_name: str = struct_name.removeprefix('Vk')
            array_length: str = array.strip('[]')
            arguments: str = f'{vkless_name.lower()}->{field.name}'
            if field.wrap_params:
                arguments = field.wrap_params
            elif field.type in vulkan_structs:
                arguments = f'&{arguments}'
            elif array_length:
                arguments = f'{array_length}, {arguments}'
        elif '{arguments}' in format_string:
            raise ValueError("Struct name is required when using {arguments}.")
        else:
            arguments: str = ''  # It's not going to be used anyway.

        fields_str += format_string.format(
            name=name,
            type=type,
            array=array,
            bitfield=bitfield,
            arguments=arguments,
            ctype=ctype,
            ctypedata=ctypedata,
        )

    return fields_str.rstrip(rstrip_string)

def arg_call(
    token: Token,
    *,  # Force keyword args, as calls with positional bools are cryptic.
    add_retval: bool,
    recording: bool = False,
    wrap: bool = False,
) -> str:
    """Return arguments formatted for a call, like '(return_value, a, b)'."""
    args_str = ''

    if add_retval and token.return_value.type != 'void':
        args_str += 'return_value, '

    args_str += args_to_str(token.args, '{name}, ')

    if recording:
        args_str += 'Recording(_recorder), '

    if wrap:
        args_str += '_recorder, '

    return f"({args_str.strip(', ')})"

def driver_definition(token: Token) -> str:
    """Return a Token's C++ definition for the driver file."""
    ret_type: str = token.return_value.type
    if ret_type == 'void':
        ret_type = 'void_t'

    custom = 'CUSTOM_' if token.custom_driver else ''

    first_argument_name = ''
    if token.level in (FuncLevel.INSTANCE, FuncLevel.DEVICE):
        first_argument_name = f', {token.args[0].name}'

    params: str = args_to_str(token.args, '{type} {name}{array}, ', ', ')
    args: str = arg_call(token, add_retval=False)

    macro_name = f'VK_{custom}{token.level.name}_LEVEL_FUNCTION'
    macro_args = f'({ret_type}, {token.name}, ({params}), {args}{first_argument_name})'

    return macro_name + macro_args

def driver_call(token: Token) -> str:
    """
    Create a string containing a driver call (for gitsPluginPrePostAuto.cpp).

    Parameters:
        token: data for one version of a token

    Returns:
        A C++ driver call string. Examples:

        'wrapper.Drivers().gl.glAccum(op, value);'
        'execWrap_glGetIntegerv(pname, data);'
        'auto return_value = wrapper.Drivers().gl.glMapBuffer(target, access);'
    """

    has_retval: bool = token.return_value.type != 'void'
    retval_assignment = 'auto return_value = ' if has_retval else ''

    exec_wrap: bool = token.interceptor_exec_override is True
    function_prefix = 'execWrap_' if exec_wrap else 'wrapper.Drivers().gl.'

    driver_args: str = arg_call(token, add_retval=False)

    return f'{retval_assignment}{function_prefix}{token.name}{driver_args};'

def mako_write(inpath: str | Path, outpath: str | Path, **kwargs) -> int:
    """Render a Mako template into a file."""
    # Objects used by all (or almost all) Mako templates.
    common_objects = {
        'FuncType': FuncType,
        'FuncLevel': FuncLevel,
        'Token': Token,
        'Argument': Argument,
        'ReturnValue': ReturnValue,
        'VkStruct': VkStruct,
        'Field': Field,
        'VkEnum': VkEnum,
        'Enumerator': Enumerator,
        'AUTO_GENERATED_HEADER': AUTO_GENERATED_HEADER,
    }

    inpath = Path(inpath)
    outpath = Path(outpath)

    try:
        print(f"Generating {outpath}...")
        template = mako.template.Template(filename=str(inpath))
        rendered = template.render(**(common_objects | kwargs))
        rendered = re.sub(r'\r\n', r'\n', rendered)

        destination = Path('..') / outpath
        with destination.open(mode='w') as fout:
            fout.write(rendered)
    except Exception:
        traceback = mako.exceptions.RichTraceback()
        for filename, lineno, function, line in traceback.traceback:
            print(f"{filename}({lineno}) : error in {function}")
            print(line, "\n")
        print(f"{traceback.error.__class__.__name__}: {traceback.error}")
        return -1
    return 0

def update_token_ids(
    id_file_path: str | Path,
    destination_subpath: str | Path,
    functions: list[Token]
) -> None:
    """
    Append new token IDs (if any) to an ID file.

    Parameters:
        id_file_path: Path to the ID file.
        destination_subpath: Path to copy the file to; relative to parent directory.
        functions: List of tokens to generate IDs from.
    """
    id_file_path = Path(id_file_path)
    destination_subpath = Path(destination_subpath)

    existing_ids: set[str] = set()
    with id_file_path.open(mode='r') as id_file:
        for line in id_file:
            if line.startswith('ID'):
                existing_id: str = line.strip(',\n')
                existing_ids.add(existing_id)

    new_ids = ''
    for token in functions:
        token_id: str = make_id(token.name, token.version)
        if token_id not in existing_ids:
            new_ids += token_id + ',\n'

    if not new_ids:
        print(f"File {id_file_path} is up to date.")
    else:
        print(f"Adding new IDs to {id_file_path} ...")
        with id_file_path.open(mode='a') as id_file:
            id_file.write(new_ids)

    destination = Path('..') / destination_subpath
    print(f"Copying {id_file_path} to {destination_subpath} ...")
    shutil.copy2(id_file_path, destination)


def main() -> None:
    """Generate all the files."""
    all_tokens: list[Token] = get_functions()
    enabled_tokens: list[Token] = [f for f in all_tokens if f.enabled]
    newest_tokens: list[Token] = without_older_versions(all_tokens)

    all_structs: list[VkStruct] = get_structs()
    enabled_structs: list[VkStruct] = [s for s in all_structs if s.enabled]
    newest_structs: list[VkStruct] = without_older_versions(all_structs)

    all_unions: list[VkStruct] = [s for s in all_structs if s.type == 'union']
    enabled_unions: list[VkStruct] = [u for u in all_unions if u.enabled]


    all_enums: list[VkEnum] = get_enums()
    # Enums are always enabled.

    update_token_ids('vulkanIDs.h', 'common/include', functions=enabled_tokens)

    vulkan_layer_bin_path: str = ''
    match platform.system():
        case 'Windows':
            vulkan_layer_bin_path = '.\\\\VkLayer_vulkan_GITS_recorder.dll'
        case 'Linux':
            vulkan_layer_bin_path = './libVkLayer_vulkan_GITS_recorder.so'
        case other_system:
            raise NotImplementedError(
                f"Path to Vulkan layer dynamic library is unknown for system '{other_system}'.")
    mako_write(
        'templates/VkLayer_vulkan_GITS_recorder.json.mako',
        'layer/VkLayer_vulkan_GITS_recorder.json',
        vulkan_layer_bin_path=vulkan_layer_bin_path,
    )

    mako_write(
        'templates/vkX.def.mako',
        'layer/vkLayer.def',
        library_name='VkLayer_vulkan_GITS_recorder.dll',
        vk_functions=newest_tokens,
    )

    mako_write(
        'templates/vkX.def.mako',
        'interceptor/vkPlugin.def',
        library_name='vulkan-1.dll',
        vk_functions=newest_tokens,
    )

    mako_write(
        'templates/vulkanDriversAuto.inl.mako',
        'common/include/vulkanDriversAuto.inl',
        args_to_str=args_to_str,
        arg_call=arg_call,
        driver_definition=driver_definition,
        functions_by_level=split_functions_by_level(newest_tokens),
    )

    mako_write(
        'templates/vulkanIDswitch.h.mako',
        'common/include/vulkanIDswitch.h',
        make_id=make_id,
        make_cname=make_cname,
        vk_functions=enabled_tokens,
    )

    mako_write(
        'templates/vulkanLogAuto.inl.mako',
        'common/include/vulkanLogAuto.inl',
        version_suffix=version_suffix,
        vk_structs=dependency_ordered(all_structs),
        vk_enums=all_enums,
        vulkan_mapped_types_nondisp=vulkan_mapped_types_nondisp,
        vulkan_mapped_types=vulkan_mapped_types,
    )

    mako_write(
        'templates/vulkanLogAuto.cpp.mako',
        'common/vulkanLogAuto.cpp',
        version_suffix=version_suffix,
        make_struct_log_code=make_struct_log_code,
        vk_structs=dependency_ordered(all_structs),
        vk_enums=all_enums,
        vulkan_mapped_types_nondisp=vulkan_mapped_types_nondisp,
        vulkan_mapped_types=vulkan_mapped_types,
    )

    mako_write(
        'templates/vulkanRecorderWrapperXAuto.h.mako',
        'recorder/include/vulkanRecorderWrapperIfaceAuto.h',
        args_to_str=args_to_str,
        is_iface=True,
        vk_functions=newest_tokens,
    )

    mako_write(
        'templates/vulkanRecorderWrapperXAuto.h.mako',
        'recorder/include/vulkanRecorderWrapperAuto.h',
        args_to_str=args_to_str,
        is_iface=False,
        vk_functions=newest_tokens,
    )

    mako_write(
        'templates/vulkanRecorderWrapperAuto.cpp.mako',
        'recorder/vulkanRecorderWrapperAuto.cpp',
        args_to_str=args_to_str,
        make_cname=make_cname,
        vk_functions=newest_tokens,
    )

    mako_write(
        'templates/vulkanFunctions.h.mako',
        'common/include/vulkanFunctions.h',
        args_to_str=args_to_str,
        make_id=make_id,
        make_cname=make_cname,
        make_ctype=make_ctype,
        make_func_type_flags=make_func_type_flags,
        make_inherit_type=make_inherit_type,
        vk_functions=enabled_tokens,
    )

    mako_write(
        'templates/vulkanFunctions.cpp.mako',
        'common/vulkanFunctions.cpp',
        args_to_str=args_to_str,
        make_id=make_id,
        make_cname=make_cname,
        make_ctype=make_ctype,
        undecorated_type=undecorated_type,
        make_func_type_flags=make_func_type_flags,
        make_inherit_type=make_inherit_type,
        vk_functions=enabled_tokens,
        primitive_types=primitive_types,
    )

    mako_write(
        'templates/vulkanPrePostAuto.cpp.mako',
        'interceptor/vulkanPrePostAuto.cpp',
        args_to_str=args_to_str,
        vk_functions=[f for f in newest_tokens if f.level != FuncLevel.PROTOTYPE],
    )

    mako_write(
        'templates/vulkanHeader.h.mako',
        'common/include/vulkanHeader.h',
        decimal_str_to_hex=decimal_str_to_hex,
        args_to_str=args_to_str,
        fields_to_str=fields_to_str,
        dependency_ordered=dependency_ordered,
        vulkan_flags=vulkan_flags,
        vulkan_flags64=vulkan_flags64,
        vk_functions=newest_tokens,
        vk_structs=newest_structs,
        vk_enums=all_enums,
    )

    mako_write(
        'templates/vulkanTracerAuto.h.mako',
        'common/include/vulkanTracerAuto.h',
        args_to_str=args_to_str,
        vk_functions=newest_tokens,
    )

    mako_write(
        'templates/vulkanTracerAuto.cpp.mako',
        'common/vulkanTracerAuto.cpp',
        args_to_str=args_to_str,
        make_token_log_code=make_token_log_code,
        vk_functions=newest_tokens,
    )

    mako_write(
        'templates/vulkanLuaEnums.h.mako',
        'common/include/vulkanLuaEnums.h',
        split_arrays_from_name=split_arrays_from_name,
        vk_enums=all_enums,
        vk_unions=enabled_unions,
    )

    mako_write(
        'templates/vulkanCCodeArgumentsAuto.h.mako',
        '../CCodeFiles/src/include/vulkanCCodeArgumentsAuto.h',
        vulkan_mapped_types=vulkan_mapped_types,
        vulkan_mapped_types_nondisp=vulkan_mapped_types_nondisp,
    )

    mako_write(
        'templates/vulkanArgumentsAuto.h.mako',
        'common/include/vulkanArgumentsAuto.h',
        make_cname=make_cname,
        fields_to_str=fields_to_str,
        vk_structs=enabled_structs,
        vk_enums=all_enums,
        vulkan_mapped_types=vulkan_mapped_types,
        vulkan_mapped_types_nondisp=vulkan_mapped_types_nondisp,
    )

    mako_write(
        'templates/vulkanArgumentsAuto.cpp.mako',
        'common/vulkanArgumentsAuto.cpp',
        make_cname=make_cname,
        make_ctype=make_ctype,
        undecorated_type=undecorated_type,
        FieldInitType=FieldInitType,
        make_value_field_inits=make_value_field_inits,
        split_arrays_from_name=split_arrays_from_name,
        fields_to_str=fields_to_str,
        vk_structs=enabled_structs,
        vk_enums=all_enums,
        vulkan_structs=vulkan_structs,
        primitive_types=primitive_types,
        vulkan_mapped_types=vulkan_mapped_types,
        vulkan_mapped_types_nondisp=vulkan_mapped_types_nondisp,
        types_not_needing_declaration=types_not_needing_declaration,
    )

    enabled_non_custom_structs: list[VkStruct] = [s for s in enabled_structs if not s.custom]
    mako_write(
        'templates/vulkanStructStorageAuto.h.mako',
        'common/include/vulkanStructStorageAuto.h',
        fields_to_str=fields_to_str,
        vk_structs=dependency_ordered(enabled_non_custom_structs, use_undecorated_types=True),
        vk_enums=all_enums,
        vulkan_mapped_types=vulkan_mapped_types,
        vulkan_mapped_types_nondisp=vulkan_mapped_types_nondisp,
    )

    mako_write(
        'templates/vulkanStructStorageAuto.cpp.mako',
        'common/vulkanStructStorageAuto.cpp',
        undecorated_type=undecorated_type,
        FieldInitType=FieldInitType,
        make_value_field_inits=make_value_field_inits,
        split_arrays_from_name=split_arrays_from_name,
        fields_to_str=fields_to_str,
        vk_structs=dependency_ordered(enabled_non_custom_structs, use_undecorated_types=True),
        primitive_types=primitive_types,
    )


if __name__ == '__main__':
    main()
